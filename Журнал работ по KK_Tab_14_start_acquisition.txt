KK_Tab_14_start_acquisition


06.05.2019

Пришли к противоречию.
Если программа запускается и ждет команд от пользователя, то алгоритм работы понятный.
НО если сделать так, чтобы при запуске программы сразу запускался набор данных в потоке, то как потом попасть в режим "ручной контроллер" ???
После остановки набора в потоке по кнопке "STOP ALL" происходит остановка потоков, закрытие файла.
Порты USB-FTDI остаются открытыми, и если после остановки "STOP ALL" продолжить работать в режиме "ручной контроллер", то файл с данными будет переписываться.
Что с этим делать ?
ОСтавить так и просто иметь ввиду ?

"Запустить Набор"

* - Добавить код - обработку исключений, которые могут возникнуть при создании нового объекта класса FTDI_D2XX
 * - Привести блок схему работы программы к актуальному виду, учитывая набор в потоке при запуске, либо ожидание команд при запуске.
 * Т.е. надо создать ДВЕ версии блок схемы, для разных вариантов программы.
 *
 * Вспоминаем задачу от 23.01.2019 и понимаем, что Документацию - Manual_KK_USB_01.doc тоже надо менять.
 * - Создаем Manual_KK_USB_02.doc
 * - Переработал блок схему KK_Tab_14.vsd
 * - Добавил "Блок_Схема_накопления в потоке.vsd" где расписана работа в потоке.

Удалил (Закомментил) запуск набора, сохраняю коммит в ветке KK_Tab_14
ОСтавил запуск набора при старте программы, сохраняю коммит в ветке KK_Tab_14_start_acquisition
Создал ветку KK_Tab_14_start_acquisition


Возникла проблема, связанная с задачей 23.01.2019.
Теперь, если вначале работы необходимо поработать в режиме "ручной контроллер", то необходимо останавливать работу в потоке, а при этом
закрывается файл для записи данных.
И получается, что в ручном режиме данные в файл не пишутся, т.к. файл больше не открывается.
Надо каким-то образом предусмтотреть открытие файла с новым индексом.

Пока оставляю так до дальнейшего разбирательства c заказчиком.

23.03.2019
В работе потока А участвует ф-ция void MyThread::A_SLOT() - это слот обработки сигнала started() От потока из класса QThread,
   выполняет  Прием данных в ПК из железа, Канал А

Обнаружил в функции MyThread::A_SLOT() задержку в 50мс !!!!!! QThread::msleep(50);
Это же ПОЛНЫЙ ПИЗДЕЦ, ЖЕНЯ !!!!!!!!!!
Похоже осталось с тех времен, когда отлаживал режим "медленный поток".
Исправил на usleep(1) -  и сбой данных происходит только в самом 1-м файле, в самом начале, в пределах первых 10 посылок по 8 байт.
Надо сделать размер приемного из FTDI буфера кратным 8.
Сейчас размер буфера 0x400000 // это 4 194 304 байт !, это кратно 8...
Значит при одной из посылок буфер заполняется не полностью + винда запускает поток не регулярно + запись/открытие файла.



11.03.2019
 *
 * - Доработать код, чтобы поиск файлов начинался в текущей директории запуска проги [./] СДЕЛАНО
 * - Исправленные файлы складывать в папку ./backup СДЕЛАНО
 *
 * ФИКСИРУЕМ РЕЗУЛЬТАТ в части корректировки файлов.



07.03.2019
 * Получил рабочий вариант.
 *
 * Следует учитывать, что считывание из файла происходит в той позиции, куда попали на последней операции seek !!!
 * Забыл про это и долго потом ковырялся.
 * Отладчик так же помог.


04/02/2019
Пора создавать алогритм корректировки файлов данных, чтобы отображались спектры.
Решено перенести эту задачу в отдельное консольное приложение.

//+++++++++++++++++++
28.01.2019

 * Настроил проект FPGA, теперь пробуем отладить прогу Qt.
 * Добавил функцию void Camac_Run_Always (void)
 * По нажатию кнопки "Запустить набор" запускается Camac_Run_Always, где формируется команда N[17]A[0]F[2], DATA= 0x2222,
 * Далее, запускаем поток А, начинаем принимать из KK_USB данные непрерывно.
Это сделано. Пока идут "0000 0000" в данных.

,

23.01.2019
Вот и прошел еще 1 год с момента последней записи.
А KK_Tab_09 вообще 2 года назад запускалась последний раз...

При загрузке программы виджет индикации подключения camac_tab остается серым, несмотря на то, что в логе устройство распознанно !
Разбираемся.

Очень помогла БЛОК-СХЕМА  алгоритма программы, созданная на VISIO.

 * Сразу несколько слов по поводу индикатора.
 * Конечно хорошо при запуске прораммы, чтобы индикатор подключения сразу работал и горел красным, если девайс не подключен и зеленым - если подключен.
 * Но, тогда должен работать таймер, который регулярно будет проверять наличие девайса и реагировать соответственно.
 * А иначе, можно кабель от устройства отсоединить, а индикатор останется зеленым... что НЕВЕРНО.
 * Тогда при включении потоков таймер индикатора надо отключать...
 * А поскольку в последней редакции надо потоки сразу запускать после старта программы, то и таймер не нужен :)

Но тут возникает новое препятствие.
Имитатор KK_USB при запуске ждет команду от ПК и только после правильной команды начинает отправлять данные в ПК.
Так что на повестке дня 2 задачи, которые нужно решить одновременно.
Переделать программу Qt и проект Quartus для этих целей.

22.01.2018

Подчищаю код.

Поправил форматирование строки. Вместо %d для DWORD  поставил %ul

str.sprintf("В буфере было %lu RxxBytes байт, а считано %lu байт\n",RxxBytes, dwNumBytesRead);

тэг: лог_вывод, вывод_строки, формат чисел в строке

Остался вопрос по предупреждению, касательно регулярного выражения :
D:\QT-Projects\Camac_USB\KK_Tab_11\mainwindow.cpp:1873: warning: unknown escape sequence: '\s'
     QRegExp cmt ("^$|^\n$|^\s*#[^\n]*(?=\n|$)");
                  ^
ф-ция "parse_command_line"

Тэг: '\s'



10.01.2018

Специальная команда задания количества блоков ADP16 – N[0]*A[0]* F[17] & D[4..0].
ВВодим новую спецкоманду F[27] - STOP strobes.
Эту команду отправляем по нажатии кнопки "STO PALL", получив N[0]*A[0]*F[27], камак-логика перестанет посылать стробы S1, S2.

Возникает пересечение функционала с MainWindow::CAMAC_make_command(void).
Похоже, надо отдельную ф-цию - аналог CAMAC_make_command(void) -  делать для спецкоманд.


27.12.2017
 * Изменил ftdi_init()
 * Теперь искомый SerialNumber передается в качестве аргумента, а не "зашит" в коде ф-ции.
 * Мы запускаем ф-цию и сразу задаем девайс, который ищем, с которым дальше будем работать.
 *
 * Поправил слот нажатия кнопки "Stop Sending", теперь порты А,В - не закрываются, поток ставится на паузу.
 * И можно работать в режиме "ручной контроллер", индикатор частоты переводится в "NO CYCLE"
 *
 *
 * 26.12.2017
 *
 * Документ "AN232B-03 Optimising D2XX Data Throughput"  очень помог.
 *
 * Изменил размер буфера :
 *
 * - ftdi : 65536
 * - byInputBuffer[0x400000]  = 4 194 304
 *
 * ЗАРАБОТАЛО !!!!!!!!!!!!!!!!!
 *
 * Данные в файл пишутся ровно !!!
 *
 * Размер  FT_efficient_size 63448  -  не пригодился.
 *
 * Включил отрисовку спектров
 *
 * 25.12.2017
 *
 * Добавил ф-цию FT_ResetDevice(ftHandle_A);  FT_ResetDevice(ftHandle_B);
 * Не помогло.
 *
21.12.2017

Убираем лишнее в GUI

Обнаружил отсутствие информации в этом файле по объекту camac_tab(а по ключевому слову "мигание" - нашел).
camac_tab - это виджет индикации - маленький квадратик 30х30 пикселов.
Когда идет циклический обмен, этот квадратик меняет свой цвет зеленый-серый, так мы получаем мигание.
[см запись от 06.09.2017, вот наконец-то пригодилось !]



30.11.2017

Возник вопрос по алгоритму работы  Plot::Draw_Spectral_N_Chan_Slot (QByteArray *ibuf)
Этот слот делает выборку данных по номеру станции, типу блока.
Сейчас 4 таких варианта :
- обычный блок, для него простой спектр, данные в байте №4,5
- ADP16 блок, для него спектр Альфа, даныне в байте №6,7
- ADP16 блок, для него спектр Осколок, даныне в байте №4,5
- ADP16 блок, для него спектр Время, даныне в байте №2,3

Критерии выбора типа блока находятся в байте 1- разделитель слов и байте 8 - тип команды.

Сейчас для 3 типов данных (без времени) в 1 функции 3 куска практически одинакового кода.
Отличия только в номере байт и условии выборки.

Либо использовать 1 ф-цию для разных типов блоков с указанием аргументов по выборке.

Оставил 1 ф-цию на все типы блоков. Тогда придется диспетчировать вызов этой 1-ф-ции от разных типов блоков, если
будет включено отображение спектров одновренменно для разных типов блоков. Например, запускать эту ф-цию из разных таймеров и на каждую делать mutexlock().
Оставляем эту задачу на будущее.
Пока делаем вызов только для 1 типа блоков - этого достаточно для демонстрации.



Остается проблема "зависания" replot() при количестве точек > 5млн.

25.11.2017

За сутки накопилось 356 файлов по 8Мб
В момент моего прихода программа и зависла...
runtime error...
НАбор запущен в 16:11:39
Последняя запись в логе о размере Interval-а была в 22:16:55
Возможно как раз в это время я заходил через teamviewer.
Т.е. запись просто перестала создаваться. При этом шла запись о новом файле, записанном на диск.
Как такое может быть ???!!!
Похоже, что На размере интервала в 9млн. точек replot остановился. Но как тогда программа дальше записывала файлы на диск...

2017-11-24__22:16:55:905 > 0x7777: Interval size is 8395353 
2017-11-24__22:19:48:766 > 0xeeee: File is written on disk 
2017-11-24__22:23:21:343 > 0xeeee: File is written on disk 
2017-11-24__22:26:53:918 > 0xeeee: File is written on disk 

Запись об интервале в начале лога идет правильно - 1 раз в секунду, но !
ЗАпись об интервале в конце идет примерно каждые 2с., хотя таймер срабатывает 1 раз в сек


22:16:55:905

Запущу набор при отключенной сетевой карте, посмотрим...

Забыл отключить карту. 
ОДнако когда заешл в лооге есть запись, что в отрисовку вошли, но не вышли... :)
23.11.2017

Приступаем к оптимизации отрисовки спектров.
Вся проблема в том, что тут данные накапливаются постоянно в QwtIntervalSample.
Т.е. мы постоянно делаем ADP16_Alpha->intervals->append(QwtIntervalSample() )
А можно каждый раз очищать этот массив и создавать заново с учетом, что всего 400 пикселов.

Для начала установим HistogramStyle::Lines.
И будем рисовать гистограмму не через setSamples(*intervals);
А через drawLines	


Используем QwtPlot::axisScaleDiv	(	int 	axisId	)	const

Так получаем axisScaleDiv(axisId).lowerBound(), axisScaleDiv(axisId).upperBound() are the current limits of the axis scale.




22.11.2017

Сделал график "жёлтым", см. конструктор Plot::Plot()
Там сначала задается черная палитра для всего, а потом желтая палитра для полотна.

При такой скорости набора отрисовка спектра "глушит" пргорамму, она подвисает.
Нужно выводить на 400 пикселей ровно 400 точек. Следует создать механизм выборки из 100к точек нужных 400 и рисовать линию.

Данные из буфера перестал принимать.
Отсылаю даныне из фиксированного буфера, создаваемого в конструкторе класса FTDI_D2XX:: - все равно зависание.

4096-->8192-->16384


Поработал с отладчиком, убедился, что запись данных чередуется, то в 1 буфер, то во 2 буфер, однако,
благодаря отладчику увидел, что адрес буфера сдвигается, и при последующем возврате к этому буферу, 
данные пишутся не в начало. Т.е. надо буфер ОЧИЩАТЬ. После этого данные при возврате пишутся в начало.
Т.е. буфер не разрастается до бесконечных размеров.

Первое подозрение было такое : 
	" It means your program has tried to access memory that doesn't belong to it. 
          Basically, you have a pointer that contains an invalid value somewhere in your code - a common
          source of this error is dereferencing a NULL pointer.
        "

Оказалось все намного проще

 * Вместо  Qt::BlockingQueuedConnection поставил Qt::QueuedConnection,
 * т.к. сигнал и слот в одном потоке (но в разных классах)
 * Так набор файлов работает чётко.
 * Странно, почему раньше этого сбоя не было.
 Оставил набор файлов на ночь.
ЗА 12 часов набралось 243 файла размером 8 388 6хх байт, 1 файл за 3мин. 36с.

И берем "dereferencing a NULL pointer" на заметку

21.11.2017
Убрал в ф-ции Read_AAA "обрезание" принятых байт до 8 (т.к. считал, что приходит всегда ровно 8, и только в начальных случаях, больше 8)
и после этого скорость набора стала космической ! 

1Мб за 26с.
4Мб за 1м.46с
8Mb за 3м.32с.
При длительном наборе программа подвисает.

ЗА 1 цикл Read_A приходит не по 8 байт, а по 80, либо 642, а я их раньше обрезал, вот и медленно файл набирался.


При такой скорости набора графики сразу подвешивают программу.
Надо разбираться с отрисовкой.


20.11.2017
Оставил накопление файлов на выходные. 
Задал размер файла 0x800000 = 8Мб.
8Мб набиралось по 4 часа !!!!!!!! 
Снова запустил отключение сервисов через powershell.





17.11.2017

При отрисовке по таймеру переделаем.
Сначала все точки собираем, а уж потом ВСЕ эти точки добавляем в интервал и делаем replot.
По X 800 точек, по  Y  400. Нет смысла все их отрисовывать, надо прореживать.

* 16.11.2017
 *
 * На компьютере в ЛЯР скорость накопления файла нормальная - 1Мб за 4.5 мин. (пауза в 150мс, 100мс - одинаково)
 *
 * На компе в ЛИТ отключил некоторые службы.
 * После подключения платы КАН обратно к компу в ЛИТ скорость стала нормальная !!!! т.е. примерно 4.5мин. на 1мб
 * [4m 23s]
 * Может быть помогло отключение служб.
 *
 * Тогда продолжаем разбираться с рисованием спектров.

 * Оставил набор файла на 17 часов. Набралось 30 файлов по 8 388 608 байт с интервалом в 35 минут.
 * Набор работал стабильно.


Если во время набора запустить отрисовку спектров, то запись файла на чинает тормозить.
Без отрисовки файл набирается нормально.

Попробую перенети отрисовку в отдельный поток.


15.11.2017
//‭0x10 0000 =  1048576‬  0x40 0000 = ‭4194304‬  0x10 000 = 65536 (1min)
Пока "нормальная" скорость - это 4Мб за 17 минут. Т.е. 1Мб пишется за 4 минуты - это нормально.
Сейчас Скорость записи файла вернулась на прежний, "кривой" уровень. 12:43 - 12:55
1 Мб пишется за 12 минут !!!!!!!!! Ни в какие ворота...
Следующий файл 12:55 - 13:09 14 минут !!!!!

В проекте KK_Tab_06  скорость записи 1Мб [13:39 - 13:49] 10 минут, а должно быть 4 минуты ... [13:49 - 13:57] 8 минут

Есть идея попробовать другой компилятор, 64-разрядный.
Либо другой набор 

Скорее всего дело в винде и драйверах для FTDI.
Запустил набор файла из-под другого "сборочного" набора , другой компилятор MinGW-w64-32
Скорость примерно та же. 65536 за 2 минуты.
524288 байт за 14 минут.

65536 за 2 минуты. Убрал очистку буферов, скорость такая же - 65536 за 2 минуты.
Судя по логу мы каждые 2мс получаем по 8 байт. Значит за 1с это будет 4000 байт. 
При таком раскладе 65536 байт должно приходить за 16с, и, соответственно, 1048576 байт мы получим за 4 минуты.
Как эти 16 сек превращаются в 2 минуты ???!!! У нас потеря скорости в 7 раз !!!

2017-11-15__18:06:54:420 > 0x1000: Запущен постоянный набор2017-11-15__18:06:54:423 > 0xeeee: 8 Bytes written !
...
2017-11-15__18:08:15:624 > 0xeeee: 65536 Bytes written !

за 81с. 202ms - меньше 2 минут, все нормально ?!

ОСтавил набор файлов на ночь. См. отчет за следующий день.

14.11.2017

Скачаны последние драйвера для ft2232h, версия 2.12.28 Driver date = 16.08.2017
До этого стояла версия v2.12.16
После утсановки - фантастический рост скорости записи файла !!!!
4Мб пишутся за 1 минуту !!!!!!!!!
При этом что-то нарушается в проге и она вылетает с сообщением об ошибке.

13.11.2017

 * Пока пробую реализовать такую цепочку для принятых в ПК 8 байт от FTDI.
 * [USB==ByInputBuffer]--->[onLine-buffer for Graph]--->[buffer-for-file]--->[file on disk]

 * Разобраться, почему скорость набора файла так радикально снизилась(в 4 раза !!!).
 * Это обнаружилось после создания ф-ции MainWindow::ftdi_answer_parser(int value) в проекте KK_Tab_06
 * может перенести ф-цию из GUI в другой класс ?



03.11.2017

Убрал из Read_A весь код по дополнительному буферу.
Проеверяю время накопления файла на частоте 5кГц. 17 или 40 минут ???
За 18 минут набралось 2 091 000 байт.
Увеличу частоту до 20кГц - набор медленнее !!! за 1 час набралось 1 047 768.

Добавил виджеты для осколков и одиночного спектра.
Попробовал взять следующие FPGA-проекты, где добавлены ответы на другие команды. Поправил модуль read_byte.v
При заполненности в 98% ответ на неизвестную команду чередуется с правильным ответом.
НАдо поработать над fpga проектом еще !
Или двигаться от проекта EK_ALT_USB_77, добавляя функционал.


Схема работы с буферами.
Read_A
При накоплении нужного размера - даем сигнал и передаем указатель на текущий-полный буфер. Слот запишет файл на диск.
Переключаем область записи полученных от FTDI данных с текущего-полного буфера на пустой.
Продолжаем накпливать данные в пустой буфер

MainWindow
Слот срабатывает в главном окне.
Слот записывает файл на диск, готовит имя файла для накопления со следующим индексом.

Осталось реализовать и проверить результат.


02.11.2017

Запустил набор файлов почти на сутки. 
Начало в 18:47
Конец  в 13:58
Набралось 31 файлов с 000 до 030.

В этот раз вайл размером 4 194 304 набирался за 40 минут(частота 5кГц).
Из этих 30 файлов Минимальное время записи файла на диск 101мс, максимальное 130мс.
А в проекте KK_Tab_06 за 17 минут. 
ПОЧЕМУ ТАКАЯ РАЗНИЦА ???!!!

01.11.2017
Вот подошли к точке, когда надо создавать набор спектра через буфер.
Вообще программа должна быть заточена, чтобы рисовать спектры из текущих данных набора + запись этих данных в файл.

Т.е. данные из usb-буфера должны проходить через ф-цию отрисовки и потом в файл.
А на данный момент проходят из буфера сразу в файл.


 * Тут добавляем вкладки для спектров
 * Пока пробую реализовать такую цепочку для принятых в ПК 8 байт от FTDI.
 * [USB==ByInputBuffer]--->[onLine-buffer for Graph]--->[buffer-for-file]--->[file on disk]
 *
 * Добавление точек к спектру буду делать раз в 700мс. Шкалу Y Для спектра нужно увеличить с текущих 500 до 5000
 * - Реализована цепочка [USB==ByInputBuffer]--->[onLine-buffer for Graph]
 *   Дополнительный буфер называется FTDI_D2XX::SpectralBuffer, FTDI_D2XX::qbuf
 *
Добавил буфер в слот обработки таймера.
Вижу, что размер буфера увеличивается при каждом срабатывании таймера.

Теперь надо по таймеру брать разницу в размере буфера и отсылать на отрисовку.
Остановился на этой точке. НАдо выбрать новую порцию данных из буфера и отправить её на отрисовку.


10.10.2017
Реализована идея, озвученная 07.10.2017 о создании АНАЛИЗАТОРА ответа от функций из класса FTDI_D2XX::
Анализатор называется void ftdi_answer_parser(int);
Использование выглядит так: ftdi_answer_parser( KAN->ftdi_init() );
Т.е. запускается ф-ция KAN->ftdi_init(), а её ответ направляется в ф-цию ftdi_answer_parser в качестве аргумента.

Использование этого парсера позволит убрать соединения сигнал-слот между классами, которые мешают "изолированности"
класса FTDI_D2XX:: Т.к. эти соединения нужны только для вывода отладочных сообщений, то решаем эту задачу таким способом.
Также через сигнал-слот устанавливаются значения флагов индикации состояния подключения, что тоже можно решить через соответствующий код
возврата от функции.


09.10.2017
Непонятно, что делать с ф-цией FTDI_D2XX::Write_B_Thread()
Т.к. она в потоке и является слотом, сигнал для которого запускается из другого класса - не MainWindow.
Как быть с выводом отладочных сообщений ?
Т.е. как передать в MainWindow информацию об ошибке ?
Тут пора отключаться от текущего проекта. Пусть сторонний пользователь сам организует скоростную работу этой ф-ции.

Такой же вопрос по поводу ф-ции Read_A() т.к. эта ф-ция есть слот на сигнал от потока. И в потоке не орабатывается ответ этой ф-ции.
[Но можно сделать по-другому. Сделать слотом не Read_A(), а другую ф-цию, внутри которой запускать парсер. - Не пойдет. Парсер - элемент главного окна.]


07.10.2017
НА примере функции bool FTDI_D2XX::KK_Inhibit( char *buf_data, int buf_size )
Стало понятно, что ошибка может возникнуть в процессе выполнения нескольких операций внутри функции.
Поэтому есть мысль о создании ответа в виде СТАТУСА(структура, перечисление enum), внутри которого будет обозначено, 
на каком этапе возникла ошибка. 
Анализировать статус надо будет только если ф-ия вернула ошибку.
Так же стоит подумать о создании лог-файла работы проги, и записи туда всех сообщений об ошибках.
Для linux-версии точно нужно так сделать, там это намного проще реализовать.

06.10.2017
Подчищаю код.
Слот обработки таймера №2 сделал сразу в классе FTDI_D2XX, т.е. убрал лишнюю пару сигнал-слот.
Начал обработку возвращаемых значений своих функций.
Т.е. переделываю код этих самых функций, чтобы они возвращали значение с результатом своей работы, и соответственно анализ этого результата и последующие действия.
Начал ftdi_init(), по возвращаемому коду буду выводить в текстовом окне соответствующие сообщения, но это уже будет в классе MainWindow, а не в классе FTDI_D2XX, как было 
раньше. Т.е. класс FTDI_D2XX, таким образом, будет очищен от лишнего кода, не относящегося к нему впрямую, ВО !
Т.е. класс свою работу делает, передает результат наверх, а анализ результатов уже в классе-потребителе-родителе для класса FTDI_D2XX.

Но такой вариант кода подразумевает, что в дальнейшем ф-ция будет 


22.09.2017
 * Отрабатываю сохранение файла на диск при достижении заданного размера. (Сделано)
 * Так не надо ждать закрытия программы или принудительно останавливать набор.
 * Т.е. через некоторое время набора уже будут данные, которые можно начинать обрабатывать.
 * И если произойдет сбой в работе ПК или железа, уже какие-то данные все равно останутся.
 * Последовательность такая:
 * 0. Пишем порцию данных в файл.
 * 1. Если текущий размер больше или равен заданному, то:
 *                                - Останавливаем потоки все, т.е. обмена с KK нет.
 *                                - ЗАКРЫВАЕМ файл. Он при этом пишеться на диск.
 * 2. Добавляем к текущему имени файла индекс, т.е. увеличиваем имеющийся индекс на 1, получаем новое имя файла
 * 3. Открываем новый файл с индексом в имени.
 *       СНИМАЕМ ПОТОКИ С ПАУЗЫ, обмен продолжается
 * 4. Идем на пункт 0.

Добавил в коде запуск сигнала нажатия кнопки.
Так можно значительно и заметно сэкономть время при отладке, когда каждый раз в главном окне нужно нажать несколько кнопок для запуска процессов.

Следующая задача:
Настроить отрисовку спектра online, чтобы он брал данные из всех файлов постепенно, т.е. доработать уже имеющийся код.



21.09.2017
Работа с файлом.
Запуск набора в 12:24
Останов в 12:35:00 (точно полные 10 мин.)
размер : 2 451 440 
Скорость 4085 байт/с = 32680 бит/с. Нужно в 500раз быстрее :)

Переставил индикаторы станций, чтобы номера увеличивались слева направо.
N1     X = 1060,  Y = 549
N23    X =   45,  Y = 549

Подпись под индикатором:
N1     X = 1055
       Y = 630

N23    X = 40
       Y = 630

“Q”	“X”	F16	N16	N8	N4	N2	N1

Добавил дешифрацию команд  - для всех 3 типов команд - при выводе спектра online

//++++++++++++++++++
Заказ №51055

г. Москва, ул. Тверская, д. 24 с1.

Дубна-Москва - Накладная с номером: 1057524700

Москва-Дубна - Накладная успешно создана с номером: 1057526024 
               Заявка на вызов курьера с номером: 7274978


18/09/2017

ОБнаружил, что в RealTime режиме на компе в ЛИТ все работает, а в ЛЯР - нет !
ДЛя записи данных от ftdi файл открывался в классе FTDI_D2XX, а для RealTime режима - в MainWindow и ReadOnly.

Сделал в режиме RealTime открытие файла как элемент класса FTDI_D2XX и все заработало, однако при этом, когда останавливается набор (и файл закрывается), останавливается и RealTime отрисовка :) Поэтому пришлось добавить проверку, открыт ли файл и если нет, то открыть :)

Задача:
 * Необходимо в RealTime режиме при открытии файла считывать все данные, что есть (до конца файла на данный момент) и отрисовывать.
 * А при следующем срабатывании таймера брать следующую порцию до конца файла.


13.09.2017
Дожал запись в файл ответа от КК на команду Inhibit (F0 00 00 00 00 00 00 01)
Еще раз проверил, что нужна задержка между FT_Write и FT_Read, иначе ответ от FTDI приходит неверный.


07.09.2017
Делаем таймер запуска ftdi_inint(), если КК не подключен.
Не забываем, что ftdi_init() каждый раз меняет ft_Handle !!!

После остановки набора в потоке лампочка не всегда зеленая.
А ведь мы не отключались. Или лучше сразу делать её красной, чтобы было понятно, что надо перезапускать программу...

Лампочка после остановки всегда должна быть КРАСНАЯ, т.к. порты закрываются FT_Close(); и, сответственно, флаг KK_connected = FALSE; (не-а, не было после STOP ALL KK_connected = FALSE; после исправления все стало как надо. прим.после ) Но иногда она остается зеленой из-за того, что таймер *timer_flash еще не перекинул из зеленого в серый, а флаг KK_connected = FALSE; не был установлен по нажатию кнопки "STOP ALL".

Наладил индикацию подключения в состоянии когда еще не запущен поточный режим.
Останов таймера *timer перенес в запуск потоков, а не после сигнала от ftdi_inint(), т.к. может придти новый - обратный сигнал "отключения" от той же самой
ftdi_inint().


06.09.2017
Убедиться, что работет 1-кратная запись. + ДА, работает.


Добавил индикацию режимов работы.
Для этого создал отдельный виджет малого размера (индикатор), у которого родителем указал вкладку (Вкладка_1).
Через setGeometry разместил этот виджет в нужном месте вкладки.
Далее просто меняю цвет фона виждета по таймеру(не совсем элегантно, но функционально).
Режимы:
- КК не подключен (красный квадрат) -> Включаем таймер( ftdi_init() ), ждем подключения.
- КК подключен, нет набора (зеленый квадрат)
- КК подключен, идет набор (мигание зеленый/серый фон квадрата)
tag: мигание


05.09.2017
Проект KK_Tab_02
Проверим запись в файл через DataStream.
В поточном режиме работает.
В одиночном (разовая посылка по нажатию кнопки) - нет записи в файл, файл нулевой длины.
Разобрался. Нужно закрывать файл в деструкторе класса, тогда все работает как надо, данные в файл пишутся даже в разовом режиме.
Тут разница с прошлыми проектами в том, что в прошлых проектах, запись в файл шла в основном потоке - GUI, а в этом проекте запись в файл идет в другом потоке, не GUI.
DeleteLater () ??? Нет, достаточно просто delete KAN;

MainWindow::~MainWindow()
{
    delete ui;
    //KAN->mfile.close();
    delete KAN;
}

Т.е. в деструкторе главного окна удаляем объект класса FTDI_D2XX, и файл сам корректно записывается и закрывается. 

Переделал интерфейс программы, добавил в проект вкладки. 
Вкладка_1 - набор данных
Вкладка_2 - отрисовка спектров.

ВСЕ РАБОТАЕТ СРАЗУ !!!!!!!!
Осталось подчистить мелочи - границы виджетов, шкалы, изменение шкалы и т.д.

04.09.2017
 * Проект KK_Tab_01
 *
 * Приступаем к отрисовке спектров.
 * Создаем  2 вкладки  - обмен с ПК, - отрисовка спектра.
 *
 * - выбор из файла данных на отрисовку
 * - запись в файл и работа программы
 * - почему в поточном режиме запись в файл только через flush, а не write
 * - учесть сериализацию при записи файла.


29.08.2017
Вернемся к проблеме передачи массива между классами.

Данные на передачу в FTDI формируются в главном окне через GUI.
Т.е. массив данных на передачу (Array_1) принадлежит классу MainWindow.
Сама передача данных в FTDI реализована в другом классе (другом потоке) - не MainWindow, иначе будет тормозить GUI (у него всегда свой поток, основной).
Т.е. функция, которая отсылает массив в FTDI находится в другом классе - FTDI_D2XX (так класс называется).
Эта функция вызывается как слот на сигнал из третьего класса, занимающегося обработкой потоков - класс MyThread.

Т.е. в потоке (класс MyThread) отсчитывается время в мкс, эмиттируется сигнал, который связан со слотом в классе FTDI_D2XX.
Этот слот в классе FTDI_D2XX отправляет данные в железо. Данные, казалось бы, уместно передать через указатель на массив, как аргумент функции -слота.
Но не получится, т.к. слот связан с другим классом, в котором не виден класс MainWindow, а значит и его данные.



25/08/2017

Добавил красок в GUI. Выделил в рамку и задал желтый цвет фона у данных NAF.
Написал более подробную инструкцию к программе, файл d:\FLNR\USB_Camac\Инструкция по работе с программой.docx

11.08.2017
ДОбавил ф-цию Read_Single() для записи в файл в 1-кратном режиме.
Подредактировал Camac_Make_Command, теперь в 1-кратном режиме данные также формируются из GUI.
Поставил в ф-ции Read_A чтение байт в количестве RECEIVE_SIZE, теперь данные "ложатся" ровно в файл.


25.07.2017
проект KK_Thread_USB_03

Добавил кнопку "Данные", по которой ставятся биты данных на передачу из ПК в КАМАК.

Следует поискать более простой, более элегантный способ передачи массива между классами, чем поэлементное копирование.
Это необходимо, чтобы в будущем можно было класс FTDI_D2XX:: использовать в других проектах.
Сделал пока так:
memcpy(OutputBuffer, OutBuffer, TRANSFER_SIZE);

Но все равно как-то некрасиво. Происходит копирование данных из одной области памяти в другую, а надо всего лишь передать указатель на нужную область памяти.

1. Через сигнал/слот передать массив между 2 классами можно, но наш массив в "третьем", отличном от этих двух.
2. Отдельнми сигнал/слотом передать указатель на массив, а в слоте скопировать область памяти в "локальный", "видимый" в классе массив.
3. Вызывать отправку данных из ПК в ЮСБ из ГУИ - нехорошо, очень медленно будет работать. А данные-то на отправку толко из ГУИ можно получить.
Вот и приходится отдельный сигнал/слот для копирования данных из ГУИ городить.

//+++++++++++++++++++++++
20.07.2017
Продолжаю с проектом KK_Thread_USB_03
Настраиваю надежную передачу данных между классами через указатель на массив, а не сам массив.

 * Создал сигнал MainWindow::push_data_buffer(char * OutBuffer), связал его со слотом класса FTDI_D2XX::Get_Buffer_Slot(char * OutBuffer);
 * Внутри этого слота элементы массива, указатель на который передан в слот, копируются в соответствующие элементы массива, видимого для класса FTDI_D2XX.
 * Это очень ТУПО !!! но по-другому пока не работает.
 *
 * Передать указатель между сигналом и слотом - не проблема. Беда в том, что в данном случае массив с данными ни в одном из этих классов не находится !
 * классы MyThread и FTDI_D2XX связаны сигналом и слотом, а массив, в котором данные, объявлен в третьем классе -  MainWindow
 * Поэтому приходится эмиттировать отдельный сигнал { push_data_buffer(byOutputBuffer); }, по которому массив из MainWindow копируется в другой массив
 * внутри FTDI_D2XX. Далее приходится связывать сигнал MyThread с простым слотом FTDI_D2XX, внутри которого уже вызывается функция с указателем массива в качестве аргумента.
 * Следует поискать более простой, более элегантный способ передачи, чем поэлементное копирование.



//+++++++++++++++++++++++++++++++++++++++++
12.07.2017
Библиотеку chrono собрал. Положил на ВМ.
Теперь задача создать проект.
 нет .lib файла, только .dll и .a
 на этом пока закончим.

//+++++++++++++++++++++++++++
11.07.2017
Распаковался без ошибок архив boost_1_60_0.zip (boost_1_60_0_sforge.zip), скачанный с sourceforge, размер 131Мб.
Архив размером 65Мб с ошибками, не распаковывается.

https://bitbucket.org/-username/-reponame/get/-commitCODE.tar.gz

https://bitbucket.org/uts-jinr/qt_camac/get/a3eb47d.tar.gz

for VM:
b2 release define=BOOST_USE_WINAPI_VERSION=0x0501 --build-dir=c:\pub\boost_xp toolset=gcc --with-library-name=chrono --build-type=complete stage

for host PC:
b2 release define=BOOST_USE_WINAPI_VERSION=0x0501 --build-dir=D:\Qt\boost_xp toolset=gcc --with-chrono --build-type=complete stage


//+++++++++++++++++++++++++++++++++++++++++++++++++
10.07.2017
hdd virtualbox
"C:\Program Files\Oracle\VirtualBox\VirtualBox.exe"
C:\Users\evkuz-adm\VirtualBox VMs\xp_ek_clone\xp_ek_clone-disk1.vmdk

Динамически расширяющийся образ
- Увеличил образ ХДД на виртуальной машине до 50Гб https://tavportal.ru/archives/573
- Поставил Qt 5.6.2  и 4.8.4
- Подключил к ВМ драйвера FTDI под Windows XP  http://www.ftdichip.com/Drivers/VCP.htm 
  Release date 2012-04-13, version 2.08.24	

- ЗАпустил на 5.6.2 проект FTDI_List. РАБОТАЕТ !!!!!
- Скачал boost_1_60_0, она работает под  windows xp

следующая задача: 

- Собрать boost_1_60_0 под  windows xp
- Настроить буфер обмена с ВМ
- Подключить boost_1_60_0
- Подключить проект Timer_01
- подключить на ВМ boost for Qt.


//+++++++++++++++
05.07.2017
При запуске проги на компе А.Н. она зависает, если запускаются потоки.
НА компе стоит Windows XP. И библиотека boost скорее всего из-за этого подвешивает всю работу, т.к. эта библиотека 
была собрана под windows 7.
Поэтому сейчас встал вопрос о создании проги именно для Xp, для этого сейчас будут скачивать Qt + boost весии, пригодные для xp.
Попробую это все поставить на виртуальную машину XP.

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06.06.2017

Опять не работала запись в файл из-за отсутствия flush().


31.05.2017
Сделал циклический обмен - работает !!!
Несмотря на flush() данные в файл пишутся нормально, поток и GUI не тормозит.
И даже если убрать flush() данные также пишутся в файл и еще быстрее...
********************
ОБнаружил, что у меня массивы byOutputBuffer и byInputBuffer
Объявлены и в MainWindow и в FTDI_D2XX
Следует с этим разобраться. И передавать данные на отправку через указатель, а считанные данные передавать в MainWindow тоже через указатель.
Это нужно сделать, чтобы избавиться от использования в подключаемом классе глобальных переменных для проекта.
НАдо все данные передавать через указатель.


//+++++++++++++++++++++++++++++++++++++++++++++++++
30.05.2017

Остановился на состоянии 
Qt : KK_Thread_USB_02 
fpga : EK_ALT_USB_Modes_05
 1 кратный режим. 

Почти 2 часа разбирался почему нет записи в файл.
Оказывается нужна была еще функция flush(). 
Непонятно, почему раньше все работало без неё ??!!

В 1-кратном режиме нужно вводить паузу между Write_B и Read_A, иначе не пишутся даныне в файл .
Выявил это случайно, решив проверить как отработала функция Write_B, и поставив вывод текстового сообщения в GUI.

ДОбавил паузу Sleep(1); между этими функциями в 1-кратном слоте и заработало стабильно.
При этом все равно обязательно наличие flush() при записи в файл.  ???????? ПОЧЕМУ ?????????
*************
Теперь придется ставить проверку на 1-кратный/поточный режим обмена, т.к. при поточном обмене каждый раз вызывать flush() - это 
потеря всех преимуществ поточности.
*************************************

Следующая задача :
- подключить циклический режим до 20кГц
//+++++++++++++
29.05.2017
НА сегодня имеем качественное улучшение работы GUI.
Теперь GUI в проекте Thread_Delay_02 не виснет и при этом работают потоки для каналов A B чипа FTDI.
Достигнуто это за счет переноса выполнения операций  из GUI потока (класс MainWindow), запускаемых из evevnt-loop потока, в отдельный класс - не GUI поток.
Следует учесть, что при этом изменилась область видимиости переменных. Так, теперь ftHandle не виден в MainWindow !

fpga: EK_ALT_in_02   (*.pof файл 190C25)
qt  : Thread_Delay_02

Задача:

- Подключить потоки к GUI ручного контроллера.
  Поправил код для 4 кнопок: старт/стоп ОТправка to FTDI и старт/стоп считывание из FTDI
- Наладить работу дешифратора команд от ПК.

Сегодня прога работает не так, как в минувшую пятницу !!! Write_B глючит и интервал не 50 мкс., а 500 !!!!!!!!
KK_Thread_03    - работает на 50мкс.
Thread_Delay_02 - не работает. только на 100мкс.
Thread_Delay_01 ( копия KK_Thread_03) работает на 50мкс.

Thread_Delay_02 Получен через коммит с git-а из проекта Thread_Delay_01

Случайно выяснил причину изменения в работе :

Функция Write_B(), строчка:
ftStatus = FT_Purge(ftHandle_B, FT_PURGE_TX);
Это очистка буфера. В прошлых версиях была закомментирована. А тут почему-то я убрал комментарий и вот такой результат.
!!!!!!!!!!!!!!!!! СССУУУУУУУУУККААААААААА !!!!!!!!!!!!!!!!

Для получения 1 байта надо переходить на отправку данных из FTDI в ПК по сигналу SIWU, а значит надо менять прошивку FPGA.
На этом шаге остановился, т.к. надо вспоминать прошивку для fpga.

//++++++++++++++++++++++++
26.05.2017

ЗАдача:
- Переименовать on_pushButton_stop_All_clicked() в on_STOP_SEND_pushButton_clicked() [Сделано]
- ДОбавить поток А по аналогии с потоком В в отдельный от GUI класс. Сделано.
- Добавить запись в файл. Сделано


//+++++++++++++++++++==
25.05.2017


Вот и пригодилось хранение всего кода для FTDI в отдельном файле marsohod.cpp

Т.е. схему запуска потоков сохраняю, меняю только видимость кода из файла marsohod.org, чтобы использовать его 
ф-ции в event-loop.

ui->FTDI_List_textBrowser->append 
printf
*************
Т.к. работа с Ftdi убрана в отдельный класс, то отладочные сообщения из функций, например "ftStatus = FT_Open(DevNumber_B, &ftHandle_B);", теперь 
хрен увидишь в главном окне. Надо городить дополнительные сигналы-слоты.
Т.е. на каждую кнопку в Ui надо свою пару сигнал/слот для передачи сообщения в ftdi (открыть порт ftdi, закрыть порт ftdi).

**********
Каждый раз, когда запускаем  функцию :
ftStatus = FT_GetDeviceInfoDetail(DevNumber_B, &Flags, &Type, &ID, &LocId, SerialNumber, Description, &ftHandle_B);

!!!!!!!!!!!!!!!!!Значение &ftHandle_B меняется !!!!!!! Поэтому получать этот указатель надо только 1 раз за весь код !!!!!!!!!!!!!!
*********************
GUI уже не тормозит при интервале 50мкс для передачи данных ПК---------->FTDI
При 30мкс. уже тормозит, но еще работает :)
*****************************************



24.05.2017

При настройке потока в блоке connect применена опция Qt::BlockingQueuedConnection.
После этого прошло зависание GUI, но интервал между импульсами RXF увеличился до 500мкс  !
В общем весь обмен по USB нужно прописывать в коде event-loop самого потока.
Сейчас там только сигнал, который обрабатывается слотом в основном потоке.
*************************************************************************
Для улучшения работы потков возьму за основу проект KK_Thread_03.
Новый проект называется Thread_Delay_01

23.05.2017

GUI тормозит из-за потоков, а не из-за записи в файл.
Запись в файл отключил, а зависание GUI осталось.
Попробовал объединить в 1 потоке запись в USB FTDI и чтение из USB-FTDI.
GUI все равно зависает. Это зависит от частоты опроса.
на 5 кГц уже начинается. А на 2кГц еще нормально - и в файл пишет и GUI не виснет.

Надо разбираться.



29.03.2017
Фиксируем результат. Проект KK_Thread_USB_02.
Потоки отключены, здесь тестируется 1-кратный цикл: запись из ПК в USB и сразу чтение из USB в ПК.
При запуске программы 1 раз в начале вызываем ftdi_init(), которая только открывает порты.
Установлено, что размер буфера FTDI можно задавать только тому буферу, который считывает данные из ПК.
А буфер на отправку в ПК остается 4096 байт, поэтому при каждом цикле приходится буфера очищать, т.к. у нас размер посылки 4 байта из ПК и 8 байт В ПК.

При нажатии на кнопку "ЗАДАТЬ" из ПК в USB отправляется 4 байта. Плата КАН принимает эти байты, и в ответ отсылает в USB(FTDI) 5 фиксированных байт 0x77, 0x78, 0x79, 0x7A, 0x7B, 
которые пишутся в файл.

В этом проекте добавлена существенная фича:

Перед считыванием данных из FTDI в ПК сначала проверяется статус очереди, - сколько байт доступно для чтения из буфера.
И после этого считываются ВСЕ доступные байты в буфере - очень удобно при тестировании/разработке.

01.03.2017
Залил на git репозиторий qt_camac, ветка KK_Thread_USB_02.

Выяснилось почему не запускался поток для канала А.
Всему виной Timer, по которому запускалас ф-ция ftdi_init(), внутри которой было открытие порта А и закрытие, 
если не удавалось его открыть(т.е. он уже октрыт был, тогда все равно закрыть и при последущем запуске таймера порт уже нормально октрывается)
Я его отключил в MainWindow(), чтобы наблюдать правильные интервалы для канала В на осциллографе.
НО эта ф-ция запускается 1 раз еще в самом начале в MainWindow(). И получалось, что 1 раз порт А открыли, а при нажатии кнопки - еще раз. Вот и ошибка.


28.02.2017

Написан дешифратор полученных данных int Data_Parser(void); возвращает 1 если данные не распознаны, и 0 - если данные распознаны
Парсер работает согласно протокола в файле D:\FLNR\USB_Camac\Формат данных.docx
Парсер запускается после записи данных в файл. 
Необходимо начать использоавть QDatastream::QDatastream(QByteArray * a, QIODevice::OpenMode mode)

27.02.2017

 * Добавляем возможность выбора частоты обмена с USB, Либо разовая команда/посылка.
 *
 * Т.к. частота задается в конструкторе потока, то следует переделать сигналы/слоты для потока(добавить параметр в сигнал).
Изменения в логике работы.

ftdi_init теперь не открыавет канал, т.к. вызывается по таймеру и проверяет наличие USB портов.
И открывает порты, если они есть.
Т.е. теперь ftdi_init служит для индикации наличия/отсутствия подключения-связи с USB.
Поэтому порт ЮСБ теперь открываетя только по кнопке. Значит, если однократное срабатывание, 
то надо либо каждый раз закрывать порт, либо делать проверку, чтобы не открывать повторно.
Это важно, т.к. в ftdi_init() порт А уже открывается, поэтому при нажатии кнопки для порта А, будет попытка повторно открыть порт, что приведет к ошибке, и 
поток не запустится.



27.01.2017
ДОработать разрыв связи по USB во время чтения из ЮСБи в ПК.
Индикатор и надпись статуса должны правильно отрабатыват.


25.01.2017
(+)Объединяем проекты KK_Thread_04 и KK_USB_02 - создаем 1 рабочий вариант ручного контроллера.
Проект d:\QT-Projects\Camac_USB\KK_Thread_USB_01 (не путать с d:\QT-Projects\EK-Threads\EK_Thread_USB_01\)



24.01.2017
Проект KK_USB_02. Создан интерфейс ручного контроллера.
НАбор NAF задается в 3 разных окнах и выбранные значения отображаются в виде битов команды из 4 байт, 
которая в итоге будет отправлена в USB.
Также созданы "лампочки" сигналов X,Q  16бит данных, считанных из USB.


18.01.2017
KK_Thread_04. Проект для работы с 1 каналом в обе стороны, в 2 потока. Канал в режиме Asynchronous FIFO.
При чтении из железа в ПК идут только сигналы TXE# и WR#
А при записи в железо из ПК идут все сигналы: RXF#, RD#, TXE#, WR# !!! Почему ???

Проблема с остановкой потока.
Помогла только перезагрузка компа. А это серьезный звоночек !!!



17.01.2017

Порпобовал Boost, скорость передачи ПК--->железо увеличилась !!!
Интервал между посылками около 50мкс.
Проект KK_Thread_03.

16.01.2017
Проверил работу проекта в Linux. Результат такой же.
НИсколько не быстрее винды !!!

Будем пробовать Boost

13.01.2017

Обнаружено, что функция Write работает заметно медленнее, чем функция Read.
Для этой проверки специально был переделан fpga-проект, чтобы запись из ПК в фпга была по каналу А,
а чтение в ПК из фпга - по каналу В.
В обоих случаях работа функции записи медленнее. И для канала А и для канала В.