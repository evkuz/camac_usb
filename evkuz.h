#ifndef EVKUZ
#define EVKUZ

/*  https://mayaposch.wordpress.com/2011/11/01/how-to-really-truly-use-qthreads-the-full-explanation/
 *
 *  http://qtsimplify.blogspot.ru/2013/05/reading-n-bytes-of-data-from.html
 *
 * git add *.h *.cpp *.pro *.ui *.txt *.exe *.vsd *.bin
 * git push https://uts-jinr@bitbucket.org/uts-jinr/qt_camac.git KK_Tab_10
 *
 *
 *
 * KK_Tab_14_start_acquisition
 * ОСтавил запуск набора при старте программы, сохраняю коммит в ветке KK_Tab_14_start_acquisition
 *
 * fpga: D:\FPGA\Projects\Camac_USB\EK_ALT_USB_81
 *
 * 19.06.2019
 * Вчера был блэкаут, не все успел.
 * - Удалил 2 вкладки "tab_ADP16_Alpha_Spectral", "tab_FISSION"
 *   Right click ->page 4 of 4-> Delete
 * Сохраняю коммит
 *
 * //++++++++++++++++++++++++
 * 18.06.2019
 * Ветка KK_Tab_14_start_acquisition пойдет в production, поэтому надо взять все улучшения из ветки 15
 * 
 * - Убрать лишние вкладки
 * 
 * 15.05.2019
 * - Откатился на предыдущий коммит.
 * - Вернулся к предыдущей цветовой гамме на вкладке "KK_Manual", Виджет индикатора связи виден.
 * - Поправил тип у слота MainWindow::Camac_N_NOT_Connected_Slot(int)
 * Фиксирую состояние в новом коммите.
 *
 *
 *
 *
 * 15.05.2019
 * - После смены цвета фона на вкладках стали невидны индикаторы X, Q, режима работы.
 *   Разбираюсь.
 * - Для начала сделать, чтобы при запуске программы, в отсутствие связи с КК виджет индикации режима работы был черного цвета.
 *
 * В результате исправления пропал виджет индикатора режима работы.
 * Решено откатиться не предыдущий коммит 0ba9b8a.
 *
 * 13.05.2019
 * Изменил цвет фона на вкладках
 * background-color: rgb(188, 199, 170);
 *
 * 06.05.2019
 *
 * Возникла проблема, связанная с задачей 23.01.2019.
 * Теперь, если вначале работы необходимо поработать в режиме "ручной контроллер", то необходимо останавливать работу в потоке, а при этом
 * закрывается файл для записи данных.
 * И получается, что в ручном режиме данные в файл не пишутся, т.к. файл больше не открывается.
 * Надо каким-то образом предусмотреть открытие файла с новым индексом.
 *
 * ...
 * Добавил открытие файла с новым индексом сразу после его закрытия в ф-ции MainWindow::on_Stop_ALL_pushButton_clicked().
 * Это действие выполняет сигнал make_io_file_signal();
 * Слот этого сигнала make_io_file_slot(); - находится в классе FTDI_D2XX
 * Так удобнее, т.к. внутри класса FTDI_D2XX и происходит открытие файла для записи и формирование его имени с индексом.
 *
 * - Еще надо разобраться с отрисовкой одиночного спектра. При смене №станции надо очищать окно. Пока не могу проверить на железе,
 *   но в голове надо держать.
 *   Скорее всего придется тест провести на данных из файла.
 *
 * - Также следует добавить обработку исключений (exceptions), в местах, где это может случиться.
 *
 * 06.05.2019
 * Задача для следующего проекта :
 *
 * - Добавить код - обработку исключений, которые могут возникнуть при создании нового объекта класса FTDI_D2XX
 * - Привести блок схему работы программы к актуальному виду, учитывая набор в потоке при запуске, либо ожидание команд при запуске.
 * Т.е. надо создать ДВЕ версии блок схемы, для разных вариантов программы.
 *
 * Вспоминаем задачу от 23.01.2019 и понимаем, что Документацию - Manual_KK_USB_01.doc тоже надо менять.
 * - Создаем Manual_KK_USB_02.doc
 * - Переработал блок схему KK_Tab_14.vsd
 * - Добавил "Блок_Схема_накопления в потоке.vsd" где расписана работа в потоке.
 * - Убрал при старте вызов Camac_Run_Always();
 *
 *  30.04.2019
 * При останове набора в файл, если он меньше заданного размера (4-8-16 МБ) не пишутся уже набранные данные.
 * Так не должно быть.
 *
 *  - Проверить запись файла при остановке набора в потоке. [Сделано]
 *  - Следует учесть, что при закрытии файла программа в текущем состоянии не проверяет, открыт ли файл, если далее возобновить набор.
 *    Значит на сегодня, при останове набора надо программу перезапускать, если понадобится снова запустить набор, включая работу в режиме
 *    "Ручной контроллер"
 *
 * Фиксируем результат. Сохраняем коммит.
 *
 *  27.03.2019
 *
 * В функции-обработчике нажатия кнопки "ЗАДАТЬ" on_SEND_TO_USB_pushButton_clicked() следует добавить сообщения в лог.
 *
 *  Т.к. это ручной режим, то в этой ф-ции добавляем сообщения в ЛОГ, с указанием деталей:
 *  станция, канал, данные и т.д.
 *
 *
 *  20.02.2019
 *
 * Надо быстрее реплотить шкалу когда число точек больше 1 млн.
 * Для этого шкалу надо начинать не с 0, а с 1млн. и т.д.
 *
 * При смене номера станции продолжает расти в логе число точек.
 * Также продолжает расти гистограмма на экране. Это ошибка, надо исправить.
 *
 *
 *
 *
 *
 *  19.02.2019
 * При остановке набора, в лог продолжает сыпаться надпись
 * "...Number of points : 756584 "
 * Надо с этим разобраться. (timer_2 не останавливается ?) Разобрался, Таймер останавливается.
 *
 * Номер канала в станции - лишняя информация. Этих данных нет в ответе от FTDI, поэтому и при отрисовке спектра
 * мы не сможем нарисовать данные от конкретного канала. Поэтому из GUI можно убрать номер канала в станции.
 *
 * 04.02.2019
 * Пора создавать алгоритм корректировки файлов данных, чтобы отображались спектры.
 * - Если 1-й байт не 0xF0, удаляем все байты сначала, пока не будет 0xF0
 * - Далее проверяем, чтобы шли верные пачки, т.е. 1-й байт 0xF0, 8-й байт 0x80, если не так, то удаляем сразу 8 байт (всю пачку) далее удаяем по 1 байту,
 *   пока не получим 1-й байт 0xf0 ?
 *   Либо удаляем не всю пачку, а только, пока не получим 0xf0
 *
 * 02.02.2019
 * Заметил, что если в конце файла записана посылка из 8 байт не полностью, то следующий файл начинается как раз с продолжения этой посылки.
 * Следует это иметь ввиду и записать в инструкции.
 * Строчка " QThread::usleep(1);" все-таки очень важна. Без нее прога виснет.
 *
 *
 *
 * 28.01.2019
 * Настроил проект FPGA, теперь пробуем отладить прогу Qt.
 * Добавил функцию void Camac_Run_Always (void)
 * По нажатию кнопки "Запустить набор" запускается Camac_Run_Always, где формируется команда N[17]A[0]F[2], DATA= 0x2222,
 * Далее, запускаем поток А, начинаем принимать из KK_USB данные непрерывно.
 * При этом должен работать канал B.
 * Реакцию проги на данные по каналу B, при работающмем потоке А допишу позже.
 *
 *
 * 25.01.2019
 * Разбиваем задачу на более простые.
 * Нужно запустить поток А на передачу данных из FTDI в ПК, и поток B при этом тоже должен работать.
 * Основная работа будет с FPGA.
 *
 * Фиксируем, что в этом проекте также срабатывает одиночная команда.
 * Команда N[17]A[0]F[2], DATA= 0x2222 -  ПРОХОДИТ, файл записывается.
 * Т.е. передаем в MAX2 буфер [0x11 0x20 0x22 0x22], получаем ответ от блока MAX2 "fifo_out_Spectral_N17"
 *
 * Следующая задача :
 * Задать команду N[17]A[0]F[2], DATA= 0x2222 при загрузке программы.
 * По команде N[17]A[0]F[2], DATA= 0x2222, запускать считывание потока А, а в fpga запускать постоянную отправку данных по SIWU
 *
 *
 * 24.01.2019
 * Меняем проект для отладки на имитаторе.
 * Используем FPGA прошивку [00174691  00174211]
 * 1. Отправляем в FTDI код 0x22222011 вместо NAF, получаем ответ.
 * ########################################################################
 * KK_Tab_12
 * fpga: D:\FPGA\Projects\Camac_USB\EK_ALT_USB_81
 *
 * 25.01.2019
 * Зафиксируем, что смогли запуститься в этой точке.
 * Одиночная команда N[17]A[0]F[2], DATA= 0x2222 -  ПРОХОДИТ, файл записывается.
 *
 *
 *
 *
 *
 * 23.01.2019
 * Запуск потока начинаем сразу, как только ф-ция ftdi_init обнаружит и распознает устройство.
 *
 * Все забыл... как работала связка MAXII + FTDI + KK_Tab ???
 * Какие коды надо посылать в MAXII + FTDI, чтобы получить ответы, имитирующие реальное железо !!!!!!
 *
 * ...
 *
 * Ищем, вспоминаем.
 *
 * Сразу несколько слов по поводу индикатора.
 * Конечно хорошо при запуске прораммы, чтобы индикатор подключения сразу работал и горел красным, если девайс не подключен и зеленым - если подключен.
 * Но, тогда должен работать таймер, который регулярно будет проверять наличие девайса и реагировать соответственно (т.е. регулярный запуск ftdi_init).
 * А иначе, можно кабель от устройства отсоединить, а индикатор останется зеленым... что НЕВЕРНО.
 * Тогда при включении потоков таймер индикатора надо отключать...
 * А поскольку в последней редакции надо потоки сразу запускать после старта программы, то и таймер не нужен :)
 *
 * - Надо переделать отправку команды под специальные коды, зашитые в FPGA.
 * - Также переделать, чтобы при запуске программы уже были установленны нужные значения NAF + data
 *
 * 0x22222011
 *
 *
 * 23.01.2019
 * Сделали первое включение контроллера в этом, 2019 году.
 * Сразу проявились недочеты.
 *
 * 1. При запуске программы сразу включить постоянный опрос буфера и записывать в файл.
 * По кнопке "Stop All" это должно останавливаться.
 *
 * 2. В окне "Single" сделать проход по разным станциям.
 * Т.е. возможность поменять станцию, и нажать "Показать Real Time"
 *
 * При "возврате" на ранее посмотренный single начинаем все точки отрисовывать заново,
 * хранить их не надо.
 * Т.е. при смене номера мы очищаем окно, очищаем массив точек и в тот же массив пишем данные для другой станции.
 *
 * 3. Кнопка "Запустить набор" ???
 *
 *
 * Задачи обозначили приступаем к выполнению.
 * Значит при загрузке программы надо сразу включать поток на считывание. И если данные в буфере есть, то пишем в файл, если нет, то ничего не делаем.
 *
 * Переходим к следующему проекту.
 *
 *
 *
 *
 * 18.01.2019
 * Переделал проверку команд в файле.
 * Теперь алгоритм такой :
 * - Сначала парсим все строки.
 * - Если находим ошибку в записи команды - выходим с ошибкой,пишем в лог, ни одну команду не выполняем.
 * - Если ошибок в командах нет, возвращаемся в начало файла и выполняем последовательно все команды, по одной в строке.
 * - Строки комментариев игнорим, ошибкой не считаем.
 * - В завершении этой ф-ции пишем в лог, сколько команд было выполнено.
 *
 * Еще надо сделать проверку на наличие команд, т.е. ситуация, когда только комментарии, а команд нет.
 *
 *
 *
 *
 * 11.01.2019
 *
 * Изменил сообщение от ftdi_init(), теперь, если не может открыть и канал А и канал В, это считаем, что устройство отсутствует, т.е. не подключено.
 * Делаем соответствующую запись в лог.
 *
 * Сделал проверку в обработчике командного файла.
 * Теперь, если устройство не подключено, то никакие команды не выполняем, пишем об этом в лог.
 *
 * Еще надо сделать проверку на наличие командного файла.
 *
 *
 * 09.01.2019
 *
 *
 * ==============================================================
 *
 * 09.01.2019
 *
 * Следует доработать ф-цию ..., берущую NAF из командного файла.
 * Ф-ция должна сначала пропарсить ВСЕ строки из командного файла и если хотя бы одна строка не верная, то НЕ ВЫПОЛНЯТЬ ни одну команду.
 * Сейчас это не так работает. Переходим к следующему проекту.
 *
 *
 * 22.01.2018
 *
 * Проект очень близко к финальной точке.
 * - почистить код (Сделано. Ни одного warning-а)
 * - Подумать на счет переделки кода для переноса/портирования проекта на Linux
 * - Опять же задача разделить классы.
 * - После остановки набора имеем несколько байт '0xCC' (неизвестная команда) в файле набора.
 *   Надо определиться, как с этим быть и задокументировать это решение.
 *
 *
 *
 * FTDI - класс для связи с ftdi-устройствами
 * CAMAC - класс для работы с объектами КАМАК - контроллеры, блоки в этом стандарте.
 *
 *
 *
 * 12.01.2018
 *
 * Удалил окно отладки "FTDI_List_textBrowser", т.к. уже давно все пишу в лог-файл.
 *
 * 11.01.2018
 *
 * только "пуск" - F27,  "стоп" - F25
 *
 * 10.01.2018
 *
 * Создаем отдельную функцию для формирования спец-команд КК. (СДЕЛАНО)
 * Суть функции - заполнить правильно массив byOutputBuffer[] и скопировать данные массива byOutputBuffer в массив внутри класса FTDI_D2XX.
 * Camac_SPEC_Command(UINT8 F_number, UINT16 F_DATA), аргументом будет номер ф-ции F и данные.
 *
 *  Надо дождаться окончания посылок в потоке.
 *  После этого отправлять спец-команду. А так она отправляется 8-10 раз, пока поток не остановится.
 *  Примечательно, что буфер на отправку успевает измениться, а поток не успевает остановиться и 8-10 раз посылает
 *  спец-команду.
 *
 *
 *
 * 08.01.2018
 *
 * Добавляю очистку/"зануление" приемного буфера из FTDI  byInputBuffer
 * // А теперь еще и занулим byInputBuffer
 * memset(byInputBuffer, 0, sizeof(byInputBuffer));
 *
 * И надо продумать такое зануление на момент запуска потока.
 *
 *
 *
 * 28.12.2017
 *
 * Изменил настройки git в локальном репозитории этого проекта.
 * файл '.git/config'
 * ДОбавил строку 'quotepath = false'
 * Теперь названия файлов по-русски отображаются нормально
 *
 * [core]
        repositoryformatversion = 0
        filemode = false
        bare = false
        logallrefupdates = true
        symlinks = false
        ignorecase = true
        hideDotFiles = dotGitOnly
        quotepath = false

 *
 *
 * 27.12.2017
 *
 * Изменил ftdi_init()
 * Теперь искомый SerialNumber передается в качестве аргумента, а не "зашит" в коде ф-ции.
 * Мы запускаем ф-цию и сразу задаем девайс, который ищем, с которым дальше будем работать.
 *
 * Поправил слот нажатия кнопки "Stop Sending", теперь порты А,В - не закрываются, поток ставится на паузу.
 * И можно работать в режиме "ручной контроллер", индикатор частоты переводится в "NO CYCLE"
 *
 *
 * 26.12.2017
 *
 * Документ "AN232B-03 Optimising D2XX Data Throughput"  очень помог.
 *
 * Изменил размер буфера :
 *
 * - ftdi : 65536
 * - byInputBuffer[0x400000]  = 4 194 304
 *
 * ЗАРАБОТАЛО !!!!!!!!!!!!!!!!!
 *
 * Данные в файл пишутся ровно !!!
 *
 * Размер  FT_efficient_size 63448  -  не пригодился.
 *
 * Включил отрисовку спектров
 *
 * 25.12.2017
 *
 * Добавил ф-цию FT_ResetDevice(ftHandle_A);  FT_ResetDevice(ftHandle_B);
 * Не помогло.
 *
 *
 *
 *
 * 21.12.2017
 * Проект KK_Tab_10 меняем GUI
 *
 * Создаю новый объект класса camac_paint:: - это индикатор X(виджет).
 *
 *
 *
 *
 * 19.12.2017
 *
 * Менял размеры буфера byInputBuffer и приемного буфера FTDI - FT_SetUSBParameters(),
 * Менял интервал запуска потока А - QThread::usleep(10/40/100);
 * Не помогло. Все равно сбой в данных.
 *
 *
 *
 *
 * 11.12.2017
 *
 * Если в файле накопления происходит сбой в порядке следования байтов, то почему спектры продолжают расти ????
 * Ведь при таком "сдвиге" не должна срабатывать выборка.
 *
 *
 * 01.12.2017
 * Фиксируем результат. Считаем это production версией.
 * Скорость отрисовки теперь укладывается в интервал таймера 1с., если заменить при записи в лог вычисление размера интервала
 * dot_number = this->intervals->size();
 *   на просто вывод числа точек в этом интервале  * Ch_Data
 *
 * При числе точек 5.5млн запись в логе с интервалом в 1.5с. Запись в лог идет уже после отрисовки гистограммы.
 *
 * Последняя запись в логе о размере интервала :
 * 2017-12-01__16:45:02:290 > 0x0000: Number of points : 8389901
 *
 * При этом активно работал с компом все время, что шел набор.
 *
 * Если ставить частоту обмена 20 кГц, то файл 8 Мб набирается за 1 минуту.
 *
 * запустил набор на скорости 10кГц. Посмотрим время последней записи.
 *
 * 2017-12-01__18:35:32:451 > 0x1000: Запущен постоянный набор
 * ...
 * 2017-12-02__04:12:29:951 > 0x0000: Number of points : 8399953 последняя запись.
 * Набралось 625 файлов с интервалом в 2 минуты.
 *
 *
 *
 *  30.11.2017
 *
 * Поправил ф-цию Plot::Draw_Spectral_N_Chan_Slot (QByteArray * ibuf)
 * Теперь в этой ф-ции 1 кусок кода для отрисовки любого из типов блоков.
 * А условие для выборки задается через switch в начале ф-ции.
 * Теперь остается вопрос как рисовать спектры от разных типов блоков одновременно в разных вкладках ?
 * т.е. экземпляр этой ф-ции будет вызываться разными сигналами, например от разных таймеров.
 * И надо предусмотреть чтобы в случае одновременного вызова этой ф-ции разными таймерами все отрабатывало правильно.
 * Код типа команды сейчас передается из класса MainWindow  в класс Plot через сигнал/слот из обработчкиа timer_2
 *
 * Оставляю пока так, для демонстрации этого достаточно.
 *
 * Последняя запись в логе о размере интервала :
 * 2017-12-01__00:42:09:374 > 0x0000: Interval size is 8388201
 *
 * Далее программа работала еще 8 часов, т.е. за эти 8 часов набирались файлы, о чем шла запись в лог.
 *
 *
 *
 *  28.11.2017
 * Переношу функцию MainWindow::Draw_Spectral_N_Chan_Slot (QByteArray * ibuf) в класс Plot::
 * Надеюсь скорость отрисовки гистограмм улучшится. Как минимум выиграем на уменьшении пары сигнал-слот.
 * Теперь все внутри класса Plot. Оставил пока только набор 1-ного спектра.
 *
 * Так сделано в тестовом проекте kk_usb_00. Таймер в 1сек. в легкую отрисовывает 8192 точек.
 * Это при том, что здесь за 1 цикл таймера добавляется 512 точек.
 *
 * На данный момент отрисовка гистограмм зависает на массиве точек в 8-9млн. Будем разбираться.
 * Предварительно сохраняю коммит.
 *
 * Далее, при отрисовке спектров ADP16 придется добавлять указатель на элемент класса Plot, либо на виджет.
 * Либо, создать список виджетов и по индексу в этом списке ссылаться на виджет.
 *
 *
 * 27.11.2017
 *
 * Добавляю функционал "СПЕЦКОМАНДА"
 *
 *
 * 24.11.2017
 *
 * Добавил очистку QwtIntervals. Этот массив может иметь размер не более int, что составляет
 * int max = 2 147 483 647 == 0x7FFF FFFF
 * Поэтому, при достижении этого размера QwtIntervals очищаю.
 * Хотя очень мала вероятность, что буфер достигнет такого размера, все же 2Гб это очень много.
 *
 * Есть идея перенести индикатор обмена данными из виджета на mainwindow, так его будет видно из любой вкладки.
 *
 * Запустил набор на выходные. Первый файл записан в 16:15. программ вышла с ошибкой в 13:12 на след. день.
 *
 * На размере интервала в 9млн. точек replot остановился
 *
 *
 * Фиксруем результать. KK_inhibit и цветовая палитра сохранена.
 *
 * Подправил нажатие кнопки Inhibit, теперь, если ответ приходит неверный, то не вызывается ftdi_init.
 * Надо дорабатывать прошивку fpga, что-то в ней с этим неправильным ответом.
 *
 *
 * Проверяю работу программы с включенным набором спектров.
 * Вроде не тормозит, и файл накпливается с прежней скоростью и спектр отрисовывается.
 *
 * Поработаю над цветом фона
 * background-color: rgb(255, 223, 170);
 * tab_widget background-color: rgb(208, 255, 234);
 * Если задать цвет фона mainwindow в креаторе, то не видно графиков, они под этим цветом.
 *
 *
 * 23.11.2017
 * Фиксируем результат, сохраняем коммит.
 * Накопление файлов и отрисовка фиксированной линии в спектре работает без сбоев.
 * НАдо переделать отрисовку, чтобы не рисовать тысячи точек, а всего лишь не более 400 пикселов - y_max для виджета.
 *
 *
 * 22.11.2017
 *
 * Вместо  Qt::BlockingQueuedConnection поставил Qt::QueuedConnection,
 * т.к. сигнал и слот в одном потоке (но в разных классах)
 * Так набор файлов работает чётко.
 * Странно, почему раньше этого сбоя не было.
 *
 * 17.11.2017
 *
 * Буду добиваться нормальной работы отрисовки, чтобы она не тормозила набор файла.
 * Задачи:
 * - Перенести отрисовку спектров из GUI в отдельный поток
 * - запуск таймера 2 перенести из GUI в отдельный поток
 * - Попробовать mutex-ы
 *
 * Данные, пришедшие из ftdi пишутся и в буффер и в файл.
 * Тормоз начинается, когда мы берем даныне из файла и отправляем их на отрисовку.
 * 2мин.12сек. файл размером 0x80000 = 524288
 *
 * Файл размером 0х800000 = 8 388 608 пишется 4 часа !!!(должно быть около 35 минут), а 0х400000 за 17 минут...
 * Значит службы винды тормозят ???
 *
  //services.msc
  // mmc devmgmt.msc
* //control sysdm.cpl,,3
 *
 * 16.11.2017
 *
 * На компьютере в ЛЯР скорость накопления файла нормальная - 1Мб за 4.5 мин. (пауза в 150мс, 100мс - одинаково)
 *
 * На компе в ЛИТ отключил некоторые службы.
 * После подключения платы КАН обратно к компу в ЛИТ скорость стала нормальная !!!! т.е. примерно 4.5мин. на 1мб
 * [4m 23s]
 * Может быть помогло отключение служб.
 *
 * Тогда продолжаем разбираться с рисованием спектров.
 *
 * Если во время набора запустить отрисовку спектров, то запись файла на чинает тормозить (в 4 раза).
 * Без отрисовки файл набирается нормально.
 *
 * Оставил набор файла на 17 часов. Набралось 30 файлов по 8 388 608 байт с интервалом в 35 минут.
 * Набор работал стабильно.
 * После записи файла на диск стабильно 2 строки подряд в логе "Read_AAA()->FT_GetStatus()->Данных От FTDI нет"
 * Возможно из-за задержки sleep(20) Установил sleep (50) и надпись пропала.
 *
 * Делаем коммит перед дальнейшей работой.

   В следующем состоянии Попробую перенети отрисовку в отдельный поток.

 *
 *  14.11.2017
 *  После обновления драйверов FTDI не работает проект KK_Tab_09 в поточном режиме, а проект KK_Tab_06, с теми же
 *  драйверами   - РАБОТАЕТ !!!
 *  Разбираюсь в коде. Read_A в момент смены файла для записи.
 *  Поток летит очень быстро, поэтому все проблемы.
 *
 *
 *
 * 13.11.2017
 * + Добавлены графики для ADP16 - альфа и осколок.
 * + Имена графиков(класс Plot::) и виджеты приведены в соответствие
 *
 * Сохраняем коммит перед следующей задачей :
 * Разобраться, почему скорость набора файла так радикально снизилась(в 4 раза !!!).
 * Это обнаружилось после создания ф-ции MainWindow::ftdi_answer_parser(int value) в проекте KK_Tab_06
 * может перенести ф-цию из GUI в другой класс ?
 *
 *
 * 10.11.2017
 * Задачи:
 * - Добавить отрисовку Альфа и Фижн для ADP16
 * - Улучшить работу шкалы.
 * - не забываем, что в "..KK_Tab_09/Backup/" хранится код, следящий за правильностью командного файла, и если хотя бы одна строка неверная,
 *   то НИ ОДНА команда из файла не выполняется.
 *   Надо этот код "скрестить" с текущим.
 *
 * + Сделана отрисовка 1-чного спектра во вкладке Single
 * + Привести код в соответствие объектам. Сейчас Hist_Fission = new Plot (ui->SINGLE_widget, "Histogram", 0.0, Fission_X_Limit, 0.0, 4096, FALSE);
 *   Гистограмма для осколка рисует одиночный спектр. А должно быть :
 *
 * + Hist_Single для ui->SINGLE_widget [А сейчас Hist_Fission для ui->SINGLE_widget]
 * + Hist_Fission для ui->FISSION_widget, "ADP16 Fission" [А сейчас Spectral_Fission для ui->FISSION_widget]
 * + Hist_Alpha для ui->ALPHA_widget [Сейчас связи не созданы]
 *
 *
 * 09.11.2017
 * + В Ответ на каждую команду должен приходить X. Если его нет, значит блок отсутствует в крейте.
 *   Добавил в лог ответ на это событие.
 * + Ошибка при выполнении из командного файла.
 *   2017-11-09__16:46:20:818 > 0x0001: ftdi_init()->Error in getting the number of devices
 *   Это из-за неверного присвоения кода возврата
 *
 * Предусмотреть Очистку буфера после остановки набора !!!
 * В ф-ции Read_A_Single() указывался размер буфера MIN_Rx_BUFFER_SIZE, который был 64, после исправления на 8, данные в файл пишутся корректно (нет лишних)
 *
 *
 *
 * 08.11.2017
 * Улучшаем работу командного файла. Задачи :
 * + Добавить возможность оставлять комментарии.
 * - Распознавать данные 16бит, и отправлять их вместе с коммандой, если есть.
 * + Проверять каждую строку на правильность формата, и если она неверная, то не выполнять
 * - Проверять каждую строку на правильность формата, и если хотя бы 1 строка неверная, то не выполнять НИ ОДНУ из команд !!!
 *
 * Изменил отрисовку шкалы спектра. Теперь она автоматически увеличивается х2 по оси Y при достижении Y_MAX.
 *
 *
 * 07.11.2017
 *
 *
 * Переношу запись накопленного буфера в файл в класс MyThread::
 * Передумал. Убрал паузу с потока, еще надо убрать Sleep(100); и проверить.
 *
 *
 * Почти целый день ушел на ловлю бага !!!!!!!!!!
 * Вместо increment_qbuf = BUF_01.right(f_offset);
 * Было  increment_qbuf = BUF_01.append(f_offset);
 *
 * Хорошо, что предварительно закоммитил рабочий вариант.
 *
 *
 *
 * 02.11.2017
 * Наконец, заработала передача массива QByteArray между классами. Спектр начал отображаться.
 * Добавил функционал смены буфера для записи, при достижении текущего буфера заданного размера.
 * Теперь возник вопрос с записью буфера в файл. Попробую поместить это в отдельный поток.
 * Еще необходимо подсчитать время записи файла на диск программой(около 100мс.).
 *
 *
 * 31.10.2017
 * Начинаем проект KK_Tab_09.
 *
 * Тут добавляем вкладки для спектров
 * Пока пробую реализовать такую цепочку для принятых в ПК 8 байт от FTDI.
 * [USB==ByInputBuffer]--->[onLine-buffer for Graph]--->[buffer-for-file]--->[file on disk]
 *
 * Добавление точек к спектру буду делать раз в 700мс. Шкалу Y Для спектра нужно увеличить с текущих 500 до 5000
 * - Реализована цепочка [USB==ByInputBuffer]--->[onLine-buffer for Graph]
 *   Дополнительный буфер называется FTDI_D2XX::SpectralBuffer, FTDI_D2XX::qbuf
 *
 *
 *
 *
 *
 *
 * 31.10.2017
 * Фиксируем результат. Переходим к следующему этапу.
 *
 * Установил программу SnakeTail https://github.com/snakefoot/snaketail-net/releases
 * Теперь можно следить за логом и без tail.
 * Для нормального отображения в логах строк очень помогла ф-ция str.simplified();
 * Эта ф-ция убирает все whitespace characters, а именно :
 * ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.
 *
 * Заработала команда tail из cmd.
 * Команда такая:
 * d:\QT-Projects\Camac_USB\KK_Tab_08\release>tail -F camac.log
 *
 *
 * Если КК получает "неизвестную" команду, которую не может распознать, то что он делает в ответ ??
 * Пока отладочный имитатор отвечает 8-байт '0xCC' 0xCCCCCCCCCCCCCCCC
 * При этом программа при получении такого ответа никак не реагирует, а просто записывает эти данные в файл.
 *
 * Имеет смысл включить анализ ответа в том случае, когда мы загружаем команды в КК из файла команд ???
 * И тут важно получить ответ в логе, чтобы понимать, что система настроена как надо.
 * Пока ответ не анализируем, в лог не пишем особых сообщений.
 *
 *
 * Если в лог-файл записывать английский текст, то получаем все преимущества этого способа.
 * Создал ф-цию Write_To_Log (int value, QString log_nessage)
 * Теперь сообщения в лог через неё.
 *
 *
 * 30.10.2017
 *
 * Возник вопрос по поводу записи в лог-файл.
 * через stream, тогда запись-формирование конечной строки удобно, но проблема с кодировкой.
 * Либо через file.write, тогда запись-формирование долго-криво, но все работает.
 *
 *
 *
 * Пояснение по поводу ф-ции ftdi_answer_parser(int value)
 * В этой ф-ции будем выводить только сообщения об ошибках, с кодами ошибок.
 * Сообщения в лог со статустом "NOTICE" будем писать в каждой ф-ции "по месту", т.е. в точке возникновения информации.
 *
 * Создаем файл команд камак - "./camac_commands.txt"
 * В этом файле будут храниться команды камак в формате N[(0-9)(0-9)]A[(0-9)(0-9)]F[(0-9)(0-9)] {0x0000}, по 1 команде в строке.
 * 2-Значные числа.
 * Команды будут выполнятся последовательно с 1-й строки по последнюю.
 * [08.11.2017] Для выполнения этих комманд надо нажать кнопку "Загрузить команды из файла"
 *
 *
 * Продолжаем реализацию работы с лог-файлом.
 * ВАЖНО !!!
 * Лог-файл надо открывать в первую очередь. Потом уже все остальные ф-ции, результат работы которых пишется в лог.
 * СНАЧАЛА, открыь лог-файл, а потом уже все остальные ф-ции, иначе эти ф-ции будут пытаться записать в файл, который еще не открыт.
 * В данном случае СНАЧАЛА - это после создания объекта класса FTDI_D2XX:: "KAN = new FTDI_D2XX();"
 *
 *
 *
 *
 * 27.10.2017
 *   Начинаем проект KK_Tab_08.
 *
 * - Создаем log-файл, куда заносим все ключевые точки работы программы.[СДЕЛАНО]
 * - Разобраться с кодировкой, чтобы кириллица была нормально видна
 * - Размер строки, заносимой в файл должен автоматом вычисляться.
 *
 *
 *
 * 27.10.2017
 * Фиксируем результат.
 * Проведено изменение кода по отладочным сообщениям.
 * Теперь все сообщения проходят через ф-цию ftdi_answer_parser(int value).
 * В итоге решено добавить запись сообщений в лог-файл, с последующим слежением за изменением файла, как это
 * делается командой 'tail -f' on Linux.
 *
 *
 * 25.10.2017
 * Если включить крейт, а ПОТОМ подключить кабель USB, то файл не набирается, висит RxF
 * А если сначала кабель, а потом крейт, то все работает как надо.
 *
 *     Вылавливать данную проблему поможет ф-ция ftdi_answer_parser(int value).
 * Решил модернизировать эту ф-цию, добавлю в начало строки вывода код ошибки, так легче будет искать точку возникновения ошибки, странно, что сразу не додумался.
 * Также надо избавиться от дублирования функционала ftdi_answer_parser(int value) внутри ф-ции on_INHIBIT_pushButton_clicked().
 *
 *
 * 11.10.2017
 * Начинаем проект KK_Tab_07.
 * Здесь добавляем функционал команды "записи/чтения номера «последнего» ADP16"
 *
 *
 *
 * 09/10/2017
 * Фиксируем результат. Переходим к следующему проекту.
 * Продолжаю вынос лишнего, сервисного кода из класаа FTDI_D2XX::.
 * Теперь займусь ф-цией FTDI_D2XX::Read_A_Single (void)
 * + После модернизации она должна возвращать свой статус, указатель на массив считанных данных, количество считанных байт данных. [СДЕЛАНО !]
 * + И надо добавлять как отдельную ф-цию - анализ ответа от FTDI_D2XX::Read_A_Single (). [добавлено в ftdi_answer_parser(int value) ]
 *
 * + Изменена ф-ция Write_Single_B(), теперь она имеет такой заголовок: int FTDI_D2XX::Write_B_Single(char *OutBuffer, int numbytes)
 *   Эту ф-цию, возможно, и следует использовать как базовую для отправки данных при экспорте dll.
 *   Ф-ция Write_B(char *OutBuffer, int numbytes ) отличается от Write_Single_B() только отсутствием очистки буферов, т.к. при работе в потоке, это
 *   существенно тормозит работу программы.
 * + Соответственно изменена ф-ция MainWindow::on_SEND_TO_USB_pushButton_clicked()
 * + Решено парсер ВСЕХ ответов от ftdi разместить В ОДНОЙ ф-ции - это MainWindow::ftdi_answer_parser(int value)
 *
 *
 * 06.10.2017
 * + FTDI_D2XX::Переделал ftdi_init(), теперь возвращает код ошибки. Код зависит от строки, которой произошла ошибка, т.е. коды разные для разных ошибок.
 * - FTDI_D2XX::Write_B_Single () [СДЕЛАНО 09.11.2017]
 * + FTDI_D2XX::KK_Inhibit()
 * И вот по FTDI_D2XX::KK_Inhibit() стало понятно, что хорошо бы, чтоб ф-ция, выполняющая команду камак возвращала массив (указатель) с данными,
 * полученными в ответ на эту команду, чтобы весь анализ полученных данных вынести из класса FTDI_D2XX:: ! [сделано !!!]
 * ПОЛУЧИЛОСЬ !!!!!
 * Теперь весь код анализа и отображения данных перенесем в GUI, и класс FTDI_D2XX:: станет максимально изолированным от конкретного проекта, а значит
 * его можно будет использовать в последующих проектах, и можно будет создать отдельную DLL.

 *
 * 05.10.2017
 * ОБращаем внимание, что в классе FTDI_D2XX:: большинство функций возвращают void, т.е. ничего не возвращают.
 * Необходимо их ВСЕ переделать, чтобы они возвращали осмысленное значение, по которому можно будет судить об успешности выполнения
 * этой функцией своей задачи.
 * Для начала пойдёт и тип bool, т.е. успешно выполнена ф-ция или нет.
 * Сейчас это делают сообщения, выводимые в текстовое окно, а надо также, чтобы функция возвращала значение, и по этому значению принимать дальнейшие шаги.
 *
 *
 * 27.09.2017
 * Имеем 2 способа демонтсрации online спектров.
 * В проекте KK_Tab_06 - грубо, через копию файла набора.
 * В проекте KK_Tab_05 - вроде как элегантнее, через буфер QByteArray.
 * Какой способ правильнее - пока непонятно.
 *
 * Возможно пора задуматься про инкапсуляцию объектов КАМАК.
 * Т.е. калсс FTDI_D2XX:: отвечает за связь с устройством ftdi - ну и пусть дальше отвечает.
 * А обработка принятых данных от КАМАК устройств и отрисовка спектров - это в отдельные классы.
 *
 * class Plot : public QwtPlot - Отвечает за отрисовку спектров, используя при этом ресурс гистограмм, имеющийся в либе QwT.
 *  И вот может обработку данных - станция, канал в станции, тип графика для этой станции - стоит перенести в отдельный класс.
 * Это нужно,чтобы класс FTDI_D2XX:: - связь в ftdi - был как можно более автономным, чтобы его можно было использовать в других проектах, где нет КАМАК.
 *
 * Т.е. данные для станции камак, задаваемые, через GUI, следует присваивать соответствующим переменным в классе, смотрящем за устройствами КАМАК.
 * Ведь будут разные типы блоков КАМАК: АЦП, УСИЛИТЕЛЬ, МУЛЬТИПЛЕКСОР, ADP16 - вот для них и создать класс.
 *
 * Подошли к точке, когда надо решить, как далее будет работать программа с точки зрения отображения спектров. Т.е. предстоит обсуждение "Что хотим", и по решиниям
 * этого обсуждения уже будем менять код программы.
 *
 * НАиболее вероятно, что отрисовка должна начинаться автоматом, без нажатия кнопки "ПОКАЗАТЬ Real Time", но тогда надо зафиксировать выбор станци,
 * для которой выполнять набор спектра. Или в самом графике выводить строчку с номером станции.
 * В общем пока фиксируемся в этом состоянии и переходим в режим выбора дальнейшего алгоритма работы программы.
 *
 *
 *
 * 25.09.2017
 *
 * Набрано 232 файла почти за 3 суток, общий объем 930 Мб.
 *
 *
 * 22.09.2017
 * Отрабатываю сохранение файла на диск при достижении заданного размера. (Сделано)
 * Так не надо ждать закрытия программы или принудительно останавливать набор.
 * Т.е. через некоторое время набора уже будут данные, которые можно начинать обрабатывать.
 * И если произойдет сбой в работе ПК или железа, уже какие-то данные все равно останутся.
 * Последовательность такая:
 * 0. Пишем порцию данных в файл.
 * 1. Если текущий размер больше или равен заданному, то:
 *                                - Ставим поток на паузу, т.е. поток работает, но не выполняет никаких действий, обмена с KK нет.
 *                                - ЗАКРЫВАЕМ файл. Он при этом пишется на диск.
 * 2. Добавляем к текущему имени файла индекс, т.е. увеличиваем имеющийся индекс на 1, получаем новое имя файла
 * 3. Открываем новый файл с индексом в имени.
 *       СНИМАЕМ ПОТОКИ С ПАУЗЫ, обмен продолжается
 * 4. Идем на пункт 0.
 *
 *  Задан размер файла 1 048 576 байт = 1М набирается за 3мин.
 *                   4 194 304 = 4M набирается за 17мин.
 * Размер больше в 4 раза, а время набора больше в 5.7 раз !
 * Тут возможно стоит подумать о выравнивании, подгонке под структуру ДИСКА hdd(размер кластера, цилиндра  и т.д.)
 *
 * 21.09.2017
 * Добавил дешифрацию команд  - для всех 3 типов команд - при выводе спектра online
 * Ф-ция Draw_Spectral_N_Chan_Slot (QByteArray *qbuf)
 * При этом поправил прошивку fpga для работы с блоком KK-24, проект D:\FPGA\Projects\Camac_USB\EK_ALT_USB_77
 *
 * Пробую писать на диск файл, если его размер 1Мбайт.
 * Для этого надо "ставить на паузу" поток, чтобы в fpga не отправлялись команды из ПК.
 *
 *
 * 20.09.2017
 * Вывод спектров on-line означает, что нужно одновременно писать в конец файла и постепенно считывать из начала файла.
 * Запись в файл идет часто малыми порциями. Считывание идет редко большими порциями.
 * Файл создан внутри класса, не MainWindow.

 * Данные пишутся в файл порциями по 16384 байт.
 * Файл виден на диске только после закрытия.

 * По нажатию кнопки "ПОКАЗАТЬ Real Time" запускается timer_2.
 * При срабатывании timer_2 генерит сигнал MainWindow::Get_Spectral_Points_Signal().
 * НА это срабатывает слот FTDI_D2XX::Get_Spectral_Points_Slot().
 * В этом слоте открывается файл QFile  - еще один экземпляр файла, в который идет набор данных, и считываются НОВЫЕ данные, ВСЕ.
 * т.е. вычисляется разница между текущим и прошлым размером файла - так получаем смещение, а затем считываются все байты, начиная со смещения, в буфер.
 * Файл закрываем. Отправляем указатель на буфер через сигнал FTDI_D2XX::Draw_Spectral_N_Chan_Signal(&qbuf);
 * Этот сигнал обрабатывает слот MainWindow::Draw_Spectral_N_Chan_Slot (QByteArray *qbuf); - обрабатывает данные буфера, если они относятся к
 * заданной станции и каналу, то рисует гистограмму.

 *
 *
 * 18.09.2017
 *
 * Необходимо в RealTime режиме при открытии файла считывать все данные, что есть (до конца файла на данный момент) и отрисовывать.
 * А при следующем срабатывании таймера брать следующую порцию до конца файла.
 *
 *
 * 14.09.2017
 * Переходим к следующему этапу - набор спектров.
 * Задача:
 * 1) Просмотр суммарного спектра альфа и осколков от выбранного ADP16 ( вначале у нас будет работать только один блок) – выборка по номеру станции.
 * Примерно раз в секунду вытаскиваются данные «альфа» из файла (без остановки набора) – 13 старших бит (байты 4 и 5).
 *
 * - Потребуется изменение проекта fpga. Будем получать данные от станции N=17, канал №1.
 * - Набрать файл с данными от станции N=17, канал №1.
 * - Построить спектр с данынми из файла.
 *
 * Т.к. чип fpga заполнен, то придется удалять из него ответ на некоторые текущие комманды, а значит функционал Qt-проекта тоже изменится.
 * Поэтому фиксируем результат на этой точке. Создаем коммиты и переходим к следующим проектам на Qt и FPGA.
 *
 *
 *
 *13.09.2017
 * Фиксируем результат.
 *
 * + Добавлена возможность выбирать диапазон станций, соответственно переделан код нажатия кнопки "ЗАДАТЬ". Опция проверена, работает.
 * + Проверен запуск 1-й кнопкой отправки команды на несколько станций. Кнопка "F(26)*A(0)" - чип отвечает для диапазона станций N=1-7.
 * + Дожал запись в файл ответа от КК на команду Inhibit (F0 00 00 00 00 00 00 01)
 *
 * Диапазон станций работает и по кнопке "Задать" и по кнопкам для фиксированных функций - F10, F24, F26.
 *
 *
 *
 *
 *12.09.2017
 * Надо будет создать отдельное консольное приложение для отладки RegExp по выборке диапазона N из окна диапазона станций.
 * Создано, отладил.
 *
 *
 *
 * 11.09.2017
 * восстанавливаю индикацию подключения КК через camac_tab - это виджет индикации, а не вкладка (название сбивает с толку).
 * Т.е. индикация должна загораться при получении ответа на команду Inhibit !
 *
 * Думаю, надо ли создавать отдельный класс для КК как КАМАК-устройство, с описанием его свойств ???
 * Для расшифровки ответа от КАМАК-блока создаем структуру.
 *
 * Создаем widget_list для "полосок" станций, чтобы можно было их раскрашивать в разные цвета по номеру в списке, а не по имени.
 *
 *
 *
 *
 *
 * 08.09.2017
 * Существенно переделываю GUI. Создаю картинку крейта с индикацией наличие/отсутствие блока.
 *
 * По нажатию кнопки "To File" В ftdi из ПК отправляется команда  0x00000000
 * В ответ должно придти 0xF000000000000001.
 * Если ответ верный, то N_22_widget меняет цвет, иначе N_23_widget меняет цвет.
 * Требуется доработка FPGA
 * ВСЕ СДЕЛАЛ !!!!!!! ВСЕ РАБОТАЕТ !!!!!!!!!!!! МАЛАДЕЦ ПАЦАНЧЕГ !!!!!
 *
 *
 *
 *  08.09.2017
 * + Наладил работу индикации режимов (Нужно было добавить установку флагов индикации в слот нажатия кнопки "STOP ALL").
 * + Подчистил код касаемый рисования синусов/косинусов.
 * + Создал на VISIO блок-схему  работы этого проекта, файл d:\QT-Projects\Camac_USB\KK_Tab_02\Блок_Схема_Программы_KK_Tab_02.vsd
 *
 * Пришел к выводу,что ф-ции чтения/записи из/в ftdi должны возвращать значения, сигнализирующие об успешном/неуспешном выполнении функции.
 * Пока перевариваю, готовлюсь морально к переделке кода.
 *
 *
 * 06.09.2017
 *
 *
 * + Подключены вкладки
 * + Работает набор спектров и обмен с камак одновременно в 2 разных вкладках
 * + Сделан 1й шаг по созданию индикации режима. Теперь надо прикрутить таймер к этому всему.
 *
 *
 *
 *
 *
 * 04.09.2017
 * KK_Tab_01
 *
 * Приступаем к отрисовке спектров.
 * Создаем  2 вкладки  - обмен с ПК, - отрисовка спектра.
 * Проект KK_Tab_01 будет стартовым для варианта с несколькими вкладками.
 *
 * - выбор из файла данных на отрисовку
 * - запись в файл и работа программы
 * + почему в поточном режиме запись в файл только через flush, а не write. ПАТАМУ ШТО надо закрывать файл в деструкторе.
 * + учесть сериализацию при записи файла. ДА, так тоже работает.
 *
 *
 *
 * 29.08.2017
 * Фиксируем результат.
 * В данном проекте достигнут необходимый функционал передачи данных между железом и ПК.
 * Далее необходимо развивать функционал GUI - индикация, вкладки, графики.
 *
 *
 * 25.08.2017
 * + Добавил красок в GUI. Выделил в рамку(голубая граница) и задал желтый цвет фона у данных NAF.
 * + Написал более подробную инструкцию к программе, файл "d:\FLNR\USB_Camac\Инструкция по работе с программой.docx"

 *
 *
 * 24.08.2017
 * Чистка кода. Убераю ненужные комментарии и ф-ции.
 * Добился, что компилятор выводит всего 1 предупреждение :
 * unused parameter 'numbytes' [-Wunused-parameter] для  void FTDI_D2XX::Write_B_Single(char *OutBuffer, int numbytes)
 *
 * Ну и пусть пока будет.
 *
 *
 * 17.08.2017
 * Фиксируем результат.
 * Работают кнопки "Данные 1" "Данные 2", данные в потоке пишутся правильные, без сбоев(в большей степени заслуга прошивки FPGA).
 * Поток при этом останавливать не нужно.
 * Данные в файле от разных команд приходят разные, правильные.
 *
 * Дальше уже можно на основе этих проектов отрабатывать рисование спектров.
 *
 * 16.08.2017
 *
 * Кнопку "Данные" в  "Данные 1"  + данные делаю 554433322, как зашито в fpga декодере команд.
 * "Данные 2". Слот нажатия кнопки добавить в конце сигнал emit push_data_buffer(byOutputBuffer).
 *
 *
 * 11.08.2017
 * + Сделал запись в файл в 1-кратном режиме "как было".
 * + Подправил считывание из FTDI. Теперь считывается ровно RECEIVE_SIZE байт.
 * остальные байты при следующем цикле. Актуально, т.к. размер буфера FTDI больше RECEIVE_SIZE,
 * и составляет МИНИМУМ 64 байт.
 * После этого в файле данные "ложатся" ровно, без сдвигов.
 *
 * Теперь надо отладить софт Qt так, чтобы в поточном режиме КАН отрабатывала разные команды.
 * ДОбавим кнопки "Данные 1" "Данные 2". Слот нажатия кнопки добавить в конце сигнал emit push_data_buffer(byOutputBuffer).
 *
 *
 * 10.08.2017
 * Нужно разобраться, почему в 1-кратном режиме не пишутся данные в файл.
 * А 1-кратный режим очень нужен для тестирования работы дешифратора команд в КАН.
 *
 *
 * 25.07.2017
 * fpga: d:\FPGA\Projects\Camac_USB\EK_ALT_USB_04\  ( Пока только windows 7 )
 * (Здесь исправлен модуль moor_mac, теперь работает циклически)
 *
 * ПК в USB посылает 4 байта, а в ответ получает 8 байт  0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E
 *
 *
 *
 * Добавил кнопку "Данные", по которой ставятся биты данных на передачу из ПК в КАМАК.
 * Следует учесть, что перед этим ЦЕЛЫЙ день бился, чтобы этот функционал выполнялся из функции Update_Label(void)
 * при запуске программы - и не помогло.
 * А засунуть это в обработчик нажатия кнопки "Данные" ПОСЛЕ запуска основного окна - и все заработало !!!!!!
 *
 *
 *
 *
 *
 * 20.07.2017
 * Настраиваю надежную передачу данных между классами через указатель на массив, а не сам массив.
 * Использую ф-цию FTDI_D2XX::Write_B_Single(char *OutBuffer, int numbytes)
 * Эта ф-ция принимает из GUI (класс MainWindow)данные(массив) на отправку и отсылает их обратно в GUI в текстовое окно ui->FTDI_List_textBrowser.
 *
 * Создал сигнал MainWindow::push_data_buffer(char * OutBuffer), связал его со слотом класса FTDI_D2XX::Get_Buffer_Slot(char * OutBuffer);
 * Внутри этого слота копируются элементы массива, указатель на который передан в слот, в соответствующие элементы массива, локального для класса FTDI_D2XX.
 * Это очень ТУПО !!! но по-другому пока не работает.
 *
 * Передать указатель между сигналом и слотом - не проблема. Беда в том, что в данном случае массив с данными ни в одном из этих классов не находится !
 * классы MyThread и FTDI_D2XX связаны сигналом и слотом, а массив, в котором данные, объявлен в классе MainWindow
 * Поэтому приходится эмиттировать отдельный сигнал { push_data_buffer(byOutputBuffer); }, по которому массив из MainWindow копируется в другой массив
 * внутри FTDI_D2XX.
 * Следует поискать более простой, более элегантный способ передачи, чем поэлементное копирование.
 * Например:
 * memcpy(OutputBuffer, OutBuffer, TRANSFER_SIZE);
 * Оставим пока так.
 *
 *
 *
 * 15.06.2017
 *
 * В однократном режиме необходимо наличие функции mfile.flush(), иначе данные в файл не пишутся.
 * Однако в поточном режиме данные пишутся и БЕЗ этой функции... как так ?
 *
 * Значит создаю 2 отдельные функции для 1-кратного режима и поточного режима
 *
 *
 * 06.06.2017
 *
 * Добиваюсь нормальной работы сигналов mode[1:0]
 * Для этого в ф-ции Write_B() организовал цикл, который посылает 8 посылок (по 4 байта) в режиме mod_01 (код 16'HAAAA),
 * затем  также в режиме mod_02 (код 16'HCCCC)
 *
 * Поэтому ожидаемые данные должны чередоваться:
 * - от режима mod_01 приходит 1 байт 0x44
 * - от режима mod_02 приходит 8 байт 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E
 *
 * Сделана отдельная функция Write_B_Single() для записи в 1-кратном режиме.
 *
 * НУжно передавать указатель массива в функцию как аргумент т.к. данные из главного окна иначе не видны для функции Write.
 *
 *
 *
 * 23.05.2017
 *
 * Делаем скоростную запись в файл в потоке.
 *
 * + Поправил функцию открытия файла.
 * Важное наблюдение. ДАже при отключении записи в файл полученных данных GUI висит.
 * Значит дело в правильной организации работы с потоками.
 * http://wiki.qt.io/Threads_Events_QObjects
 *
 *                                   QThread	QRunnable	QtConcurrent[1]
High level API                      	 ✘	       ✘	       ✔
Job-oriented                             ✘        ✔           ✔
Builtin support for pause/resume/cancel  ✘        ✘           ✔
Can run at a different priority          ✔        ✘           ✘
Can run an event loop                    ✔        ✘           ✘
 *
 * 14:08 start
 * 15:00 stop
 * duration 52 min. = 3120 sec
 * got 27285855 bytes for 3120 sec. = 8745 bytes/sec = 69960 bits/sec
 *
 *
 *
 * GUI thread
 *
 *
 * 23.05.2017
 *
 * Сейчас программа запускается с начальными настройками [17][12][27] - однократный режим. Init_Values(void)
 * Но для упрощения тестирования работы декодера/дешифратора на стороне фпга эти данные в функции CAMAC_make_command()
 * заменяются на
 *  ToDev_Bits = 0xAAAA;
    NAF_Bits  = 0xAAAA;

 * Фиксируем результат. Засылаем коммит.
 * Следующая задача:
 *
 * Настроить скоростную запись в файл в потоке. сейчас на частоте 20кгц программа уходит в себя и долго закрывается, как буд-то зависла.
 *
 *
 *
 * 19.05.2017
 *
 * Решаем задачу "добавить ОСТАНОВКУ передачи данных в ПК в потоке, т.к. сейчас железо продолжает слать данные в чип FTDI, даже когда программа уже закрыта."
 * Т.е. в программе-то мы поток закрыли, а fpga про это не знает и продолжает слать данные. Тут и зависание закономерно.
 *
 * Для остановки непрерывной передачи из fpga в ПК посылаем в чип команду N01 (режим mod_01). Чип получает эту команду, отсылает 1 байт в ответ в ПК и перестает
 * отправлять данные в ПК, ждет дальнейших команд.
 *
 * Для запуска fpga в разных режимах:
 *
 * - 1-кратно, режим mod_01 NAF [17][12][27]
 * - Поточно, режим mod_02  NAF [17][12][17]
 *
 *
 * 07.04.2017
 * Фиксируем результат. Создаем коммит.
 * По нажатию кнопки "Get_From_Dev" в железо отправляется 4 байта команды 1 раз и стартует поток А - прием данных в ПК, данные пишутся в файл.
 *
 *
 *
 * Запустил набор файла в 6:43, остановил в 11:03. Интервал 4часа 20 мин., 260минут.
 * Размер файла 1 186 991 035 байт, это 4 565 350 байт в минуту, или 76089 байт/сек. или 608кбит/с. при паузе в 100мкс.
 *
 * Задача:
 * - добавить ОСТАНОВКУ передачи данных в ПК в потоке, т.к. сейчас железо продолжает слать данные в чип FTDI, даже когда программа уже закрыта.
 * + Сократить интервал между сигналами SIWU, сейчас 100мкс.
 *   Удалось сократить интервал до 30мкс, запись в файл идет, но уже на 25мкс-интервале - НЕТ.
 *
 *
 * 05.04.2017
 * Обнаружилась причина зависания программы на больших скоростях потока - вывод отладочных сообщений в текстровое поле.
 * Прежде чем совсем закрыться, поток еще живет некоторое время и поэтому срабатывает вывод отладочных сообщений, что порт закрыт и данные не
 * считаны/не записаны. Вывод отключил и программа теперь "молча" зависает только на скрорости 20кГц
 *
 * 04.04.2017
 * Подключаем потоки для работы через SIWU.
 * Учитываем, что полный цикл - запись-чтение занимает 8.5мкс. Т.е. быстрее чем 1раз в 9мкс мы не управимся.
 * Округлим до 10мкс., получим частоту 100кГц. А в реальности потоки работали на частоте 20кГц.
 *
 * Потоки работают, 333Гц - ОК, 2.5кГц - ОК. Если быстрее, то через 1-2 сек. программа зависает.
 * Если ОК, то при остановке обмена по кнопке "STOP ALL" программа попадает в ошибку.
 *
 * Скорее всего, что-то с записью в файл. Нужно сделать запись в файл через поток !!!
 *
 *
 * 29.03.2017
 * Фиксируем результат. Прошивка для Альтеры 1873F8(5 байт в ПК) или 187999 (8 байт в ПК, проект EK_USB_Decoder_03.qpf).
 * Работает через SIWU.
 * Программа отправляет 4 байта (команда от ПК) в ответ принимает 8 байт.
 * Потоки отключены, здесь тестируется 1-кратный цикл: запись из ПК в USB по каналу B и сразу чтение из USB в ПК по каналу A.
 *
 * При запуске программы 1 раз в начале вызываем ftdi_init(), которая только открывает порты.
 * Установлено, что размер буфера FTDI можно задавать только тому буферу, который считывает данные из ПК.
 * А буфер на отправку в ПК остается 4096 байт, поэтому при каждом цикле приходится буфера очищать, т.к. у нас размер посылки 4 байта из ПК и 8 байт В ПК.
 * При нажатии на кнопку "ЗАДАТЬ" из ПК в USB отправляется 4 байта. Плата КАН принимает эти байты, и в ответ отсылает в USB(FTDI) 5 фиксированных байт :
 * 0x77, 0x78, 0x79, 0x7A, 0x7B,
 * Либо 8 байт для проекта EK_USB_Decoder_03.qpf :
 * 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E
 * которые пишутся в файл.
 *
 * В этом проекте добавлена существенная фича:
 *
 * Перед считыванием данных из FTDI в ПК сначала проверяется статус очереди, - сколько байт доступно для чтения из буфера.
 * И после этого считываются ВСЕ доступные байты в буфере - очень удобно при тестировании/разработке.

 *
 *
 * 17.03.2017
   Размер буфера Rx  по умолчанию 4096 байт и уменьшить нельзя ... Значит будем пробовать работать через SIWU

 *
 *
 * 09.03.2017
 *
 * 0x31  0x1C  0x2F 0x55
 *
 * Добавляю ф-ци дебага. Нужно вывести в текстовом броузере отправленные байты и полученный ответ на эти байты.
 *
 *
 *
 * 06.03.2017
 * Задать начальные значения при запуске программы.
 * Т.е. все кнопки и spin_box-ы должны быть установленны в определенные значения, с заданным цветом и т.д.
 *
 *
 * 02.03.2017
 * + Подправил отрисовку при нажатии кнопки "Сбросить".Теперь все обнуляется на экране при нажатии.
 * + Создаю таймер медленный, чтобы запускать 1-кратный цикл чтение/запись. Добавил в список частоту 250Гц (интервал 4мс.)
 *  - При таймере 4мс. в потоке В все работает.
 *  - При таймере 2мс. на осциллографе вижу 3мс. и поток долго останавливается после нажатия не кнопку.
 *    Даже исключение записи в файл не помогло, скорость не изменилась, осциллограф всеравно показывал 3мс.
 *  - При таймере 3мс. все работает быстро. на осциллографе 3мс.
 * В итоге фиксируем 3мс.
 *
 * Также попробую создать медленный таймер для записи данных на диск из буфера.
 *
 *
 *
 * 01.03.2017
 * Добавить интервал 500мкс - 2.5кГц, все равно программа затыкается
 *
 * + Залил на git репозиторий qt_camac, ветка KK_Thread_USB_02.
 *
 *
 * Есть идея включить в основном окне еще один таймер, но медленный, скажем, 100Гц и в этом таймере гонять
 * 1-кратный цикл чтение/запись
 *
 * Для индикации состояния "Подключено"/"Нет связи" сделал следующе:
 * -  остановку таймера при нажатии кнопок "Задать" и "Get_From_Dev"
 * -  Старт таймера по кнопкам "Stop Sending", "Stop Getting"
 * Пока работает как надо !
 *
 * Потоки А и В работают. ДАнные из потока А пишутся в файл.
 * ПРоблема с чтением/записью в 1 потоке. Т.е. послать данные и в этом же потоке считать - программа зависает.
 *
 * Попробовать в циклическом режиме использовать ф-ции Write_B() Read_A() не как слоты, а как обычные функции
 * Теперь:
 * Read_A()   - просто ф-ция
 * Read_AAA() - слот на поток А
 *
 *
 * Разобрался с НЕзапуском канала А по кнопке "Get_From_Dev" - проблема с повторным открытием порта в ftdi_init().
 * Но появилась проблема с 1-кратным циклом запись/считывание. Теперь в файл пишется не по 8 байт, а сразу по 2хх или 4хх байт !
 * Разобрался, проблема была в двойном запуске потока В в слоте нажатия кнопки. Текстовое окно как отладчик - рулит !
 *
 *
 *
 * 28.02.2017
 * Задачи:
 * + Сделать 1-кратную запись/считывание. Сделано по нажатию кнопки. В файл пишутся данные из FPGA.
 * + Сделать дешифратор полученных данных. int Data_Parser(void); возвращает 1 если данные не распознаны, и 0 - если данные распознаны
 * - Задача от 27.02.2017 пока в работе.
 *
 *
 *
 * 27.02.2017
 * Добавляем возможность выбора частоты обмена с USB, Либо разовая команда/посылка.
 *
 *
 * Интервал 50 мкс. = 20кГц
 *        100 мкс. = 10кГц
 *        200 мкс. =  5кГц
 *
 * Полученные частоты великоваты, быстрее не получается, разберемся с этим позже.
 *
 * Нужно доработать ф-нал, чтобы при повторном нажатии кнопки "Задать" поток перезапускался с новыми параметрами из формы.
 * Пока все работает нормально через кнопку "Stop Sending".
 * Т.е. workflow такой:
 *
 * Задать параметры через форму---->"Задать"------->"Stop Sending"-------->В начало
 *
 * А надо такой :
 * Задать параметры через форму---->"Задать"------->В начало
 *
 *

 *
 * 27.01.2017
 * Наконец сработал удачно commit bitbucket.org  {[KK_Thread_USB_01 3f67bc2]}  репозиторий: https://uts-jinr@bitbucket.org/uts-jinr/qt_camac.git
 * Ветка KK_Thread_USB_01
 * Добавлена кнопка остановки потока  A, B (как в KK_Thread_03)
 *
 * Есть проблема с потоком В - отправка данных из ПК в ЮСБи. Такой проблемы нет в KK_Thread_03
 * Источник проблемы - очистка буферов ftStatus = FT_Purge(ftHandle_B, FT_PURGE_TX);
 * В проекте KK_Thread_03(и KK_Thread_05) это закомментировано в ф-ции Write_B(), которая очень медленная по сравнению с Read_A().
 * Непонятно, почему при переносе в этот проект были сняты комментарии со строк ftStatus = FT_Purge(ftHandle_B, FT_PURGE_RX/TX);
 *
 * Убрал еще return в функциях Write_B(), Read_A(), ftdi_init().
 * Теперь не только индикатор всегда правильно показывает, но и подпись не врет :)
 *
 * Если в функции  Read_A() убрать "ftStatus = FT_Purge(ftHandle_B, FT_PURGE_RX);" то постоянные импульсы WR# пропадают. Т.е. буфер не освобождается,
 * и туда не идет запись.
 *
 * ##########################################################
 *
 * Короче, буфер надо чистить после чтения из ЮСБи в ПК (считано же байт меньше, чем размер буфера)
 *  но НЕ надо чистить при записи из ПК в ЮСБи, т.к. тогда уходит время на чистку и запись из ПК в ЮСБи работает медленнее
 *
 * ##########################################################
 *
 * Установлено, что наличие таймера (timer->start/stop) все же влияет на сигналы после остановки по кнопке. Если его не выключать, то он успевает сработать (после
 * остановки потока по кнопке "Stop...".
 * А если выключать, то сигналы на осциллографе пропадают (это очень хорошо !!!), надпись "подключено сохраняется", но индикатор связи красный(т.к. порт закрыт) !!!
 * Возможно следует подумать о дополнительном индикаторе, т.е. "подключено" и "идет передача", где "идет передача" соответствует тому, что порт открыт.
 * Т.е. возможно ситуация, когда "подключено" - зеленый, а "идет передача" - красный. Это возможно если физическое подключение есть и даже порт может быть октрыт, 
 * но данные не передаются.
 *
 * Для обнуления/очистки массива (заполнение массива нулями)  удобно использовать функцию мемсет, не надо цикл городить.
 * memset(byOutputBuffer, 0, sizeof(byOutputBuffer));
 *
 * Добавлено изменение размера буфера USB на приём/передачу. FT_SetUSBParameters(ftHandle_A,0x00040,0x00040);
 * НА скорости обмена вроде бы не сказывается, интервал между импульсами не изменился.
 *
 *
 * 26.01.2017
 * Задачи от 25.01.2017 Все сделаны.
 * Была проблема с return в ftdi_init(), который в данном конкретном месте отрабатывал некорректно.
 * После убирания return все заработало как надо. Не обязательно было тут же заканчивать работу ф-ции, там и так больше ни одно условие не выполняется,
 * если не проходят первые проверки, по которым был return
 *
 * 25.01.2017 Начали
 * + Делаем циклическую проверку ftdi_init(), чтобы отображать подключение/отлкючение USB.
 * + Вводим флаги для отслеживания состояния порта - открыт/закрыт и, соответственно, не_вызов/вызов FT_Open
 *
 *
 *
 * KK_Thread_05
 * Проверяем отправку 32бит по USB.
 * Команду формируем из 2 слов UINT16.
 * Т.е. из 2 таких слов создаем либо QByteArray(4), Либо сразу unsigned char[4].
 * Проверяем, какой вариант заработает ?
 * Работает вариант с char[4]. Массив char byOutputBuffer[]. Слово CAMAC_WORD разбивается на 4 байта,
 * которые пишутся в массив byOutputBuffer[]
 *
 *
 *
 * KK_Thread_03
 * 17.01.2017
 *
 * Подключаем boost в потоки.
 * Заработало !!!!
 * Около 50мкс между посылками! (ИЗ ПК в железку, даже с отключенной сетью)
 * Из железки в ПК через boost не работает, но быстрее чем сейчас идет передача и не надо(интервал 500нс).
 *
 * Подготовил проект к переносу на Linux(пути к файлу данных и библиотеке ft2xxx.dll).
 *
 *
 *
 *  KK_Thread_01.
 *
 * 13.01.2017
 * ФИКСИРУЕМ РЕЗУЛЬТАТ.
 * Нужный функционал получен.
 * - По кнопке "SEND to Device" запускается поток #1, в котором идет посылка данных из ПК в FTDI
 * - По кнопке "Get Data from Device" запускается поток #2, в котором идет посылка данных В ПК ИЗ FTDI
 * Задержка в 150мкс даже незаметна.
 *
 * 07.01.2016 (Дома не сидится...)
 *
 * Проект KK_Thread_01.
 * Делаем обмен по USB через потоки, т.к. нужно быстрее, чем позволяет системный таймер,
 * с минимальным интервалом 1мс. Нам надо хотябы 100мкс, т.е. в 10 раз быстрее.
 *
 * Создаем 2 окна, своё для каждого потока.
 * 1 поток - отправка из ПК в Плату по каналу В,
 * 2 поток - отправка из платы в ПК по каналу А.
 *
 *
 * 22.12.2016
 * Проект data-str2hex.
 * Решаем 2 задачи.  Посылаем по USB 8 байт, задаваемых пользователем в окне редактирования.
 * Используем плату Morph и плату Семенова Ю.Б.
 * В этом проекте данные только посылаем, поэтому запись в файл выключена.
 * Создано 2 *.exe- файла  .*_once, .*_periodic для однократной и периодической записи данных в FPGA по нажатию кнопки SEND.
 *
 * 2-я задача - совместить труд нескольких разработчиков. Либо в виде разных файлов, либо функций-блоков.
 *
 *
 * 15.12.2016
 *
 * Запись в файл настроена.
 * Фиксируем результат.
 * Переходим к следующей задаче - работа с железом в потоках.
 *
 *
 *
 * 13.12.2016
 * Проект Morph_03
 *
 * Настраиваем запись в файл.
 *
 *
 *
 * 13.12.2016
 *
 * ФИКСИРУЕМ РЕЗУЛЬТАТ !!!!!!
 *
 * Получение данных от morph в ПК настроено !!!
 * Проблема была в сигнале  SIWU_А !!!!!!
 * Он должен быть в "1", тогда и TXE#-сигнал появляется.
 * В следующем проекте, Morph_03, настроим запись в файл.
 *
 *
 * 25.10.2016
 *
 * Добавлена установка таймаутов на чтение/запись см. ф-цию set_mode()
 *
 *
 *21.10.2016
 * Проект Morph_02
 * Добавляем считывание данных после отправки команды.
 * Нужно научиться выходить по таймауту или другому условию, если данные не приходят в чип FT2232H
 * Иначе он даже ошибку не выдает, что не может данные считать.
 *
 *
 *21.10.2016
 *ФИКСИРУЕМ РЕЗУЛЬТАТ Проекта Morph_01
 * Создан каркас дешифратора команд от ПК
 * Переходим к следующему этапу.
 *
 14.10.2016
 Проект Morph_01
 Делаем логику USB-контроллера КАМАК на плате MorphIC-II
 ЗА основу взят Проект FTDI_List
 Учитываем, что в плате MorphIC-II возможен только режим 245 Synchronous FIFO

 По кнопке "FIFO OPEN" открываем порт в режиме 245 Synchronous FIFO и только.
 По кнопке "Send byte" отправляем байт в плату Morph.

 ФИКСИРУЕМ РЕЗУЛЬТАТ.
 Уложился в 1 день !!!
 Основная проблема была в ПЛИС, триггер не принимал 2 байта подряд, т.к. не очищался должным образом.



 * /
#endif // EVKUZ

